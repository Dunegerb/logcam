<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CINE-LOG.OS | Hyper-Threaded LOG Video Pipeline</title>
    <meta name="description" content="A monumental in-browser application for real-time LOG video recording and processing, built as a testament to the absolute limits of web engineering. Now featuring a hyper-threaded processing core and persistent clip database.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;700&family=Teko:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <style>
        /* [1] === CORE RESET & THEME ARCHITECTURE === */
        :root {
            --color-background: #000000;
            --color-primary-dark: #050505;
            --color-primary-medium: #111111;
            --color-primary-light: #1a1a1a;
            --color-accent: #00ffff;
            --color-accent-secondary: #ff00ff;
            --color-accent-danger: #ff4141;
            --color-accent-warning: #ffd700;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #8a8a8a;
            --font-primary: 'Teko', sans-serif;
            --font-secondary: 'Roboto Mono', monospace;
            --transition-speed-fast: 0.2s;
            --transition-speed-med: 0.4s;
            --transition-speed-slow: 0.8s;
            --blur-intensity: 8px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            background-color: var(--color-background); color: var(--color-text-primary);
            font-family: var(--font-secondary); font-size: 10px;
            -webkit-tap-highlight-color: transparent; user-select: none;
        }

        /* [2] === SPLASH SCREEN / BOOT SEQUENCE === */
        #splash-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--color-background); z-index: 10000;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: var(--color-accent);
        }
        #splash-logo { font-family: var(--font-primary); font-size: 8rem; font-weight: 600; letter-spacing: 4px; opacity: 0; transform: translateY(20px); filter: url(#glitch); }
        #splash-logo span { color: var(--color-text-primary); font-weight: 300; }
        #progress-bar-container { width: 80%; max-width: 400px; height: 2px; background: rgba(0, 255, 255, 0.2); margin-top: 2rem; opacity: 0; }
        #progress-bar { width: 0%; height: 100%; background: var(--color-accent); box-shadow: 0 0 10px var(--color-accent); }
        #splash-status { margin-top: 1.5rem; font-size: 1.4rem; letter-spacing: 1px; opacity: 0; text-transform: uppercase; }

        /* [3] === MAIN APPLICATION INTERFACE === */
        #app-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; visibility: hidden; opacity: 0;
            background: var(--color-primary-dark);
        }
        #video-viewfinder {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;
        }
        #video-viewfinder::after { /* Scanline effect */
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: repeating-linear-gradient(transparent, transparent 1px, rgba(0,0,0,0.4) 2px, rgba(0,0,0,0.4) 3px);
            animation: scanline 10s linear infinite;
        }
        @keyframes scanline { from { background-position: 0 0; } to { background-position: 0 100%; } }
        #video-element { display: none; }

        /* [4] === HEADS-UP DISPLAY (HUD) & OVERLAYS === */
        .hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: grid; grid-template-rows: 60px 1fr 120px; grid-template-columns: 160px 1fr 160px;
        }
        .hud-element { padding: 1rem; color: var(--color-text-primary); font-size: 1.2rem; text-shadow: 0 0 8px rgba(0,0,0,0.8); }

        /* Status Bar (Top) */
        #status-bar { grid-column: 1 / 4; grid-row: 1 / 2; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent); padding: 1rem 2rem; }
        #rec-indicator { display: flex; align-items: center; font-family: var(--font-primary); font-size: 2.2rem; letter-spacing: 2px; color: var(--color-text-secondary); transition: color var(--transition-speed-med); }
        #rec-indicator.recording { color: var(--color-accent-danger); text-shadow: 0 0 10px var(--color-accent-danger); }
        #rec-indicator .dot { width: 10px; height: 10px; background-color: currentColor; border-radius: 50%; margin-right: 10px; animation: pulse-standby 2s infinite; opacity: 0; transition: opacity var(--transition-speed-med); }
        #rec-indicator.recording .dot { opacity: 1; animation: pulse-recording 1.2s infinite; }
        @keyframes pulse-standby { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        @keyframes pulse-recording { 0%, 100% { transform: scale(1); box-shadow: 0 0 5px currentColor; } 50% { transform: scale(0.8); box-shadow: 0 0 15px currentColor; } }
        #timecode { font-size: 1.8rem; font-weight: 700; }
        #battery-status { font-size: 1.4rem; }

        /* Panel Generic Styling */
        .panel { background: rgba(10, 10, 10, 0.6); border: 1px solid var(--color-primary-light); backdrop-filter: blur(var(--blur-intensity)); -webkit-backdrop-filter: blur(var(--blur-intensity)); position: relative; }
        .panel::before, .panel::after { content: ''; position: absolute; width: 10px; height: 10px; border-color: var(--color-accent); border-style: solid; }
        .panel::before { top: -2px; left: -2px; border-width: 2px 0 0 2px; }
        .panel::after { bottom: -2px; right: -2px; border-width: 0 2px 2px 0; }
        .panel h3 { font-family: var(--font-primary); font-size: 1.8rem; font-weight: 400; color: var(--color-accent); margin-bottom: 0.5rem; text-align: center; }

        /* Scopes Panel (Left) */
        #scopes-panel { grid-column: 1 / 2; grid-row: 2 / 3; display: flex; flex-direction: column; gap: 1rem; padding: 1rem; }
        .scope-container { padding: 0.5rem; }
        .scope-canvas { width: 100%; aspect-ratio: 4/3; }

        /* Control Panel (Right) */
        #control-panel { grid-column: 3 / 4; grid-row: 2 / 3; display: flex; flex-direction: column; gap: 1.5rem; padding: 1rem; pointer-events: all; }
        .control-group { padding: 1rem; }
        .control-group label { display: block; font-family: var(--font-primary); font-size: 1.8rem; color: var(--color-accent); margin-bottom: 0.8rem; }
        .control-group select, .control-group input { width: 100%; background: var(--color-primary-medium); border: 1px solid var(--color-primary-light); color: var(--color-text-primary); font-family: var(--font-secondary); padding: 0.5rem; border-radius: 2px; font-size: 1.2rem; appearance: none; -webkit-appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%2300ffff'%3E%3Cpath d='M6 9L0 3h12z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 0.7em top 50%; background-size: 0.65em auto; }

        /* Main Actions (Bottom) */
        #action-bar { grid-column: 1 / 4; grid-row: 3 / 4; display: flex; justify-content: center; align-items: center; gap: 3rem; background: linear-gradient(to top, rgba(0,0,0,0.7), transparent); pointer-events: all; }
        .action-button { background: var(--color-primary-medium); border: 2px solid var(--color-text-secondary); border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all var(--transition-speed-med) ease; }
        .action-button:hover { border-color: var(--color-accent); transform: scale(1.05); }
        .action-button svg { width: 24px; height: 24px; fill: var(--color-text-primary); transition: fill var(--transition-speed-med) ease; }
        .action-button:hover svg { fill: var(--color-accent); }
        #record-button { width: 70px; height: 70px; background: var(--color-primary-dark); border-width: 4px; }
        #record-button .inner-circle { width: 80%; height: 80%; background: var(--color-accent-danger); border-radius: 50%; transition: all var(--transition-speed-med) cubic-bezier(0.68, -0.55, 0.27, 1.55); }
        #record-button.recording { border-color: var(--color-accent-danger); animation: record-pulse 1.2s infinite; }
        #record-button.recording .inner-circle { border-radius: 15%; transform: scale(0.7); }
        @keyframes record-pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 65, 65, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(255, 65, 65, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 65, 65, 0); } }
        #switch-camera-button, #gallery-button { width: 50px; height: 50px; }
        
        /* [5] === DIALOGS & NOTIFICATIONS === */
        .dialog { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10001; display: none; opacity: 0; justify-content: center; align-items: center; padding: 2rem; backdrop-filter: blur(var(--blur-intensity)); }
        .dialog-content { background: var(--color-primary-dark); border: 1px solid var(--color-accent); padding: 3rem; max-width: 500px; text-align: center; box-shadow: 0 0 30px rgba(0,255,255,0.3); }
        .dialog-content h2 { font-family: var(--font-primary); font-size: 3rem; color: var(--color-accent); margin-bottom: 1.5rem; }
        .dialog-content p { font-size: 1.4rem; line-height: 1.6; margin-bottom: 2rem; color: var(--color-text-secondary); }
        .dialog-button { background: var(--color-accent); color: var(--color-background); border: none; padding: 1rem 3rem; font-family: var(--font-secondary); font-size: 1.6rem; font-weight: 700; cursor: pointer; transition: all var(--transition-speed-fast); text-transform: uppercase; }
        .dialog-button:hover { opacity: 0.8; box-shadow: 0 0 15px var(--color-accent); }

        #notification-center { position: fixed; top: 70px; right: 20px; z-index: 9000; display: flex; flex-direction: column; gap: 1rem; }
        .notification {
            background: rgba(10,10,10,0.8); border-left: 4px solid var(--color-accent); padding: 1.5rem 2rem; backdrop-filter: blur(var(--blur-intensity));
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); font-size: 1.4rem;
        }
        .notification.error { border-color: var(--color-accent-danger); }
        .notification.success { border-color: #00ff00; }
        
        /* [6] === GALLERY VIEW === */
        #gallery-view {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9);
            z-index: 5000; visibility: hidden; opacity: 0; backdrop-filter: blur(var(--blur-intensity));
            display: grid; grid-template-rows: 60px 1fr; grid-template-columns: 1fr 400px;
        }
        #gallery-header { grid-column: 1 / 3; padding: 0 2rem; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--color-primary-light); }
        #gallery-header h2 { font-family: var(--font-primary); font-size: 3rem; color: var(--color-accent); letter-spacing: 2px; }
        #gallery-close-button { font-size: 3rem; cursor: pointer; color: var(--color-text-secondary); transition: color var(--transition-speed-med); }
        #gallery-close-button:hover { color: var(--color-accent); transform: rotate(90deg); }
        
        #gallery-clips { grid-column: 1 / 2; grid-row: 2 / 3; padding: 2rem; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1.5rem; align-content: flex-start; }
        .clip-card { background: var(--color-primary-medium); border: 1px solid var(--color-primary-light); cursor: pointer; position: relative; overflow: hidden; aspect-ratio: 16/9; transition: transform var(--transition-speed-fast), box-shadow var(--transition-speed-fast); }
        .clip-card:hover { transform: scale(1.03); box-shadow: 0 0 15px rgba(0,255,255,0.3); }
        .clip-card.selected { border-color: var(--color-accent); box-shadow: 0 0 20px var(--color-accent); }
        .clip-card video { width: 100%; height: 100%; object-fit: cover; }
        .clip-card .clip-info { position: absolute; bottom: 0; left: 0; width: 100%; background: linear-gradient(to top, rgba(0,0,0,0.8), transparent); padding: 1rem 0.5rem 0.5rem; color: var(--color-text-primary); font-size: 1.1rem; }

        #gallery-details { grid-column: 2 / 3; grid-row: 2 / 3; padding: 2rem; background: var(--color-primary-dark); display: flex; flex-direction: column; }
        #player-container { width: 100%; aspect-ratio: 16/9; background: #000; margin-bottom: 2rem; }
        #player-container video { width: 100%; height: 100%; }
        #details-meta h3 { font-family: var(--font-primary); font-size: 2rem; color: var(--color-accent); border-bottom: 1px solid var(--color-primary-light); margin-bottom: 1rem; padding-bottom: 0.5rem; }
        #details-meta pre { font-family: var(--font-secondary); font-size: 1.2rem; background: var(--color-primary-medium); padding: 1rem; white-space: pre-wrap; word-break: break-all; max-height: 200px; overflow-y: auto; }
        #details-actions { margin-top: auto; display: flex; flex-direction: column; gap: 1rem; }
        .details-button { background: transparent; border: 1px solid var(--color-accent); color: var(--color-accent); padding: 1rem; text-align: center; text-transform: uppercase; font-weight: 700; cursor: pointer; transition: background var(--transition-speed-fast), color var(--transition-speed-fast); }
        .details-button:hover { background: var(--color-accent); color: var(--color-background); }
        .details-button.danger { border-color: var(--color-accent-danger); color: var(--color-accent-danger); }
        .details-button.danger:hover { background: var(--color-accent-danger); color: var(--color-text-primary); }
    </style>
</head>
<body>
    <!-- SVG Filters -->
    <svg style="display:none">
        <defs>
            <filter id="glitch">
                <feTurbulence type="fractalNoise" baseFrequency="0.00001 0.00001" numOctaves="1" result="warp" seed="10" />
                <feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="30" in="SourceGraphic" in2="warp" />
            </filter>
        </defs>
    </svg>

    <div id="splash-screen">
        <div id="splash-logo">CINE-LOG<span>.OS</span></div>
        <div id="progress-bar-container"><div id="progress-bar"></div></div>
        <div id="splash-status">INITIALIZING KERNEL</div>
    </div>

    <div id="app-container">
        <video id="video-element" playsinline autoplay muted></video>
        <canvas id="video-viewfinder"></canvas>
        <div class="hud">
            <div id="status-bar" class="hud-element">
                <div id="rec-indicator"><div class="dot"></div><span>STANDBY</span></div>
                <div id="timecode">00:00:00:00</div>
                <div id="battery-status">BATT --%</div>
            </div>
            <div id="scopes-panel" class="hud-element">
                <div class="scope-container panel">
                    <h3>LUMA HISTOGRAM</h3>
                    <canvas id="histogram-canvas" class="scope-canvas"></canvas>
                </div>
                <div class="scope-container panel">
                    <h3>LUMA WAVEFORM</h3>
                    <canvas id="waveform-canvas" class="scope-canvas"></canvas>
                </div>
            </div>
            <div id="control-panel" class="hud-element">
                <div class="control-group panel">
                    <label for="log-profile-select">LOG PROFILE</label>
                    <select id="log-profile-select">
                        <option value="weblog">WEB-LOG (Generic)</option>
                        <option value="clog">CINE-LOG (High DR)</option>
                        <option value="slog">SAT-LOG (Punchy)</option>
                        <option value="linear">LINEAR (Passthrough)</option>
                    </select>
                </div>
                 <div class="control-group panel">
                    <label for="resolution-select">RESOLUTION</label>
                    <select id="resolution-select">
                        <option value="1080p">1920x1080</option>
                        <option value="720p" selected>1280x720</option>
                        <option value="480p">640x480</option>
                    </select>
                </div>
            </div>
            <div id="action-bar" class="hud-element">
                <div id="switch-camera-button" class="action-button">
                    <svg viewBox="0 0 24 24"><path d="M9 3L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2h-3.17L15 3H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.65 0-3 1.35-3 3s1.35 3 3 3 3-1.35 3-3-1.35-3-3-3z"/></svg>
                </div>
                <div id="record-button" class="action-button"><div class="inner-circle"></div></div>
                <div id="gallery-button" class="action-button">
                    <svg viewBox="0 0 24 24"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"/></svg>
                </div>
            </div>
        </div>
    </div>
    
    <div id="permission-dialog" class="dialog">
        <div class="dialog-content">
            <h2>ACCESS REQUIRED</h2>
            <p>CINE-LOG.OS requires access to your camera and microphone to initiate the real-time processing pipeline.</p>
            <button id="grant-permission-button" class="dialog-button">GRANT ACCESS</button>
        </div>
    </div>

    <div id="gallery-view">
        <div id="gallery-header">
            <h2>CLIP DATABASE</h2>
            <div id="gallery-close-button">&times;</div>
        </div>
        <div id="gallery-clips">
            <!-- Clip cards will be dynamically injected here -->
        </div>
        <div id="gallery-details">
            <div id="player-container">
                <!-- Selected video player will be injected here -->
            </div>
            <div id="details-meta">
                <h3>METADATA</h3>
                <pre id="meta-display">NO CLIP SELECTED</pre>
            </div>
            <div id="details-actions">
                <button id="download-video-button" class="details-button" disabled>DOWNLOAD VIDEO</button>
                <button id="download-meta-button" class="details-button" disabled>DOWNLOAD METADATA</button>
                <button id="delete-clip-button" class="details-button danger" disabled>DELETE CLIP</button>
            </div>
        </div>
    </div>
    
    <div id="notification-center"></div>

    <!-- The Web Worker is embedded here for simplicity in this single-file format -->
    <script id="processing-worker" type="javascript/worker">
        let logProfiles = {};
        
        function applyLogTransform(data, a, b) {
            for (let i = 0; i < data.length; i += 4) {
                const r_log = a * Math.log10(b * (data[i] / 255) + 1.0);
                const g_log = a * Math.log10(b * (data[i + 1] / 255) + 1.0);
                const b_log = a * Math.log10(b * (data[i + 2] / 255) + 1.0);
                data[i] = r_log * 255; data[i + 1] = g_log * 255; data[i + 2] = b_log * 255;
            }
        }

        function calculateScopes(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const lumaValues = new Uint8Array(data.length / 4);
            
            for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                lumaValues[j] = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
            }

            // Histogram
            const histogramBins = new Uint32Array(256).fill(0);
            for (let i = 0; i < lumaValues.length; i++) {
                histogramBins[lumaValues[i]]++;
            }

            // Waveform (Optimized Sampling)
            const waveformWidth = 128;
            const waveformHeight = 96;
            const waveformDensity = new Uint8Array(waveformWidth * waveformHeight).fill(0);
            const stepX = width / waveformWidth;

            for (let x = 0; x < waveformWidth; x++) {
                const sampleX = Math.floor(x * stepX);
                for (let y = 0; y < height; y++) {
                    const luma = lumaValues[y * width + sampleX];
                    const wy = Math.floor(waveformHeight - 1 - (luma / 255) * (waveformHeight - 1));
                    const idx = wy * waveformWidth + x;
                    if (waveformDensity[idx] < 255) waveformDensity[idx] += 8;
                }
            }
            
            return { histogramBins, waveformDensity };
        }

        self.onmessage = (e) => {
            const { type, payload } = e.data;

            if (type === 'init') {
                logProfiles = payload.logProfiles;
            } else if (type === 'processFrame') {
                const { imageData, logProfile } = payload;
                const profile = logProfiles[logProfile];
                
                if (profile && profile.b !== 0) {
                    applyLogTransform(imageData.data, profile.a, profile.b);
                }
                
                const scopeData = calculateScopes(imageData);

                self.postMessage({
                    type: 'frameProcessed',
                    payload: {
                        imageData,
                        histogramBins: scopeData.histogramBins,
                        waveformDensity: scopeData.waveformDensity,
                    }
                }, [imageData.data.buffer, scopeData.histogramBins.buffer, scopeData.waveformDensity.buffer]);
            }
        };
    </script>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const CineLogApp = {
            // ... [OMITTED FOR BREVITY - FULL CODE BELOW]
        };
        CineLogApp.init();
    });

    const CineLogApp = {
        nodes: {}, state: {}, contexts: {},
        logProfiles: {
            'weblog': { name: 'WEB-LOG (Generic)', a: 0.25, b: 150 }, 'clog':   { name: 'CINE-LOG (High DR)', a: 0.2, b: 400 },
            'slog':   { name: 'SAT-LOG (Punchy)', a: 0.35, b: 80 }, 'linear': { name: 'LINEAR (Passthrough)', a: 1, b: 0 }
        },
        worker: null, db: null,

        // [I] === INITIALIZATION & BOOT SEQUENCE ===
        init() {
            this.mapDomNodes();
            this.initWebWorker();
            this.initDatabase();
            this.setupEventListeners();
            this.updateBatteryStatus();
            setInterval(this.updateBatteryStatus, 60000);
            this.bootSequence();
        },

        mapDomNodes() {
            this.nodes = {
                splash: { screen: document.getElementById('splash-screen'), logo: document.getElementById('splash-logo'), progressBar: document.getElementById('progress-bar'), status: document.getElementById('splash-status') },
                app: document.getElementById('app-container'),
                video: document.getElementById('video-element'),
                viewfinder: document.getElementById('video-viewfinder'),
                recIndicator: document.getElementById('rec-indicator'), recIndicatorText: document.querySelector('#rec-indicator span'),
                timecode: document.getElementById('timecode'), batteryStatus: document.getElementById('battery-status'),
                scopes: { histogram: document.getElementById('histogram-canvas'), waveform: document.getElementById('waveform-canvas'), },
                controls: { recordButton: document.getElementById('record-button'), switchCameraButton: document.getElementById('switch-camera-button'), galleryButton: document.getElementById('gallery-button'), logProfile: document.getElementById('log-profile-select'), resolution: document.getElementById('resolution-select') },
                dialogs: { permission: document.getElementById('permission-dialog'), permissionButton: document.getElementById('grant-permission-button') },
                gallery: { view: document.getElementById('gallery-view'), header: document.getElementById('gallery-header'), closeButton: document.getElementById('gallery-close-button'), clipsContainer: document.getElementById('gallery-clips'), details: document.getElementById('gallery-details'), playerContainer: document.getElementById('player-container'), metaDisplay: document.getElementById('meta-display'), downloadVideoBtn: document.getElementById('download-video-button'), downloadMetaBtn: document.getElementById('download-meta-button'), deleteClipBtn: document.getElementById('delete-clip-button'), },
                notificationCenter: document.getElementById('notification-center'),
            };
        },

        initWebWorker() {
            try {
                const workerScript = document.getElementById('processing-worker').textContent;
                const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
                this.worker = new Worker(URL.createObjectURL(workerBlob));
                this.worker.onmessage = this.handleWorkerMessage.bind(this);
                this.worker.postMessage({ type: 'init', payload: { logProfiles: this.logProfiles } });
            } catch (e) {
                console.error("Monumental Failure: Web Worker could not be initialized. Performance will be degraded.", e);
                this.showNotification("Worker failed. Performance degraded.", "error");
            }
        },

        initDatabase() {
            const request = indexedDB.open('CineLogDB', 1);
            request.onupgradeneeded = e => {
                const db = e.target.result;
                db.createObjectStore('clips', { keyPath: 'id' });
            };
            request.onsuccess = e => { this.db = e.target.result; };
            request.onerror = e => { console.error("Database Error:", e); this.showNotification("Clip database failed to load.", "error"); };
        },

        bootSequence() {
            const statusUpdates = ["MOUNTING VFS...", "LOADING COLOR SCIENCE...", "INITIALIZING THREADS...", "CALIBRATING SENSORS...", "AWAITING PERMISSION..."];
            const tl = gsap.timeline({ onComplete: () => {
                gsap.to(this.nodes.splash.logo, { duration: 0.5, opacity: 0, ease: 'power2.in' });
                gsap.set(this.nodes.dialogs.permission, { display: 'flex' });
                gsap.to(this.nodes.dialogs.permission, { duration: 1, opacity: 1, ease: 'power2.out' });
            }});
            tl.to(this.nodes.splash.logo, { opacity: 1, y: 0, duration: 1.5, ease: 'power3.out' })
              .to([this.nodes.splash.progressBar.parentElement, this.nodes.splash.status], { opacity: 1, duration: 0.5 }, "-=1");
            statusUpdates.forEach((status, index) => {
                tl.to(this.nodes.splash.progressBar, { width: `${(index + 1) / statusUpdates.length * 100}%`, duration: 0.7, ease: 'none' }).set(this.nodes.splash.status, { textContent: status });
            });
        },
        
        // [II] === EVENT HANDLING ===
        setupEventListeners() {
            this.nodes.dialogs.permissionButton.addEventListener('click', () => this.requestCameraPermission());
            this.nodes.controls.recordButton.addEventListener('click', () => this.toggleRecording());
            this.nodes.controls.switchCameraButton.addEventListener('click', () => this.switchCamera());
            this.nodes.controls.galleryButton.addEventListener('click', () => this.openGallery());
            this.nodes.gallery.closeButton.addEventListener('click', () => this.closeGallery());
            this.nodes.controls.logProfile.addEventListener('change', (e) => this.state.currentLogProfile = e.target.value);
            this.nodes.controls.resolution.addEventListener('change', () => this.restartStream());
            // Delegated event listener for gallery clips
            this.nodes.gallery.clipsContainer.addEventListener('click', (e) => {
                const card = e.target.closest('.clip-card');
                if (card) this.selectGalleryClip(card.dataset.id);
            });
            this.nodes.gallery.downloadVideoBtn.addEventListener('click', () => this.downloadSelectedClip('video'));
            this.nodes.gallery.downloadMetaBtn.addEventListener('click', () => this.downloadSelectedClip('meta'));
            this.nodes.gallery.deleteClipBtn.addEventListener('click', () => this.deleteSelectedClip());
        },

        handleWorkerMessage(e) {
            const { type, payload } = e.data;
            if (type === 'frameProcessed') {
                this.contexts.viewfinder.putImageData(payload.imageData, 0, 0);
                this.drawHistogram(payload.histogramBins);
                this.drawWaveform(payload.waveformDensity);
            }
        },

        // [III] === CORE CAMERA & PROCESSING LOGIC ===
        async requestCameraPermission() {
            gsap.to(this.nodes.dialogs.permission, { duration: 0.5, opacity: 0, ease: 'power2.in', onComplete: () => this.nodes.dialogs.permission.style.display = 'none' });
            this.nodes.splash.status.textContent = 'ACCESSING CAMERA STREAM...';
            gsap.fromTo(this.nodes.splash.status, { opacity: 0 }, { opacity: 1, duration: 0.5 });
            try {
                const resolution = this.getResolution();
                const constraints = { video: { width: { ideal: resolution.width }, height: { ideal: resolution.height }, facingMode: { ideal: this.state.currentFacingMode || 'environment' }, frameRate: { ideal: 30 } }, audio: true };
                this.state.stream = await navigator.mediaDevices.getUserMedia(constraints);
                this.nodes.video.srcObject = this.state.stream;
                this.nodes.video.onloadedmetadata = () => this.startSystem();
            } catch (err) {
                console.error("Monumental Error: Camera access denied or unavailable.", err);
                this.nodes.splash.status.textContent = 'CAMERA ACCESS DENIED. REFRESH & ALLOW.';
                gsap.to(this.nodes.splash.status, { color: 'var(--color-accent-danger)' });
            }
        },

        getResolution() {
            const res = this.nodes.controls.resolution.value;
            if (res === '1080p') return { width: 1920, height: 1080 };
            if (res === '480p') return { width: 640, height: 480 };
            return { width: 1280, height: 720 };
        },

        async restartStream() {
            if (this.state.isRecording) return;
            this.stopProcessingLoop();
            if (this.state.stream) this.state.stream.getTracks().forEach(track => track.stop());
            try {
                const resolution = this.getResolution();
                const constraints = { video: { width: { ideal: resolution.width }, height: { ideal: resolution.height }, facingMode: { ideal: this.state.currentFacingMode }, frameRate: { ideal: 30 } }, audio: true };
                this.state.stream = await navigator.mediaDevices.getUserMedia(constraints);
                this.nodes.video.srcObject = this.state.stream;
                this.nodes.video.onloadedmetadata = () => {
                    this.nodes.viewfinder.width = this.nodes.video.videoWidth;
                    this.nodes.viewfinder.height = this.nodes.video.videoHeight;
                    this.startProcessingLoop();
                };
            } catch(err) {
                console.error("Failed to restart stream:", err);
                this.showNotification("Failed to switch camera at this resolution.", "error");
            }
        },

        switchCamera() {
            this.state.currentFacingMode = this.state.currentFacingMode === 'user' ? 'environment' : 'user';
            this.restartStream();
        },
        
        startSystem() {
            this.state = {
                isRecording: false, stream: this.state.stream, mediaRecorder: null, recordedChunks: [], recordingStartTime: 0,
                animationFrameId: null, currentLogProfile: 'weblog', currentFacingMode: this.state.stream.getVideoTracks()[0].getSettings().facingMode
            };
            const tl = gsap.timeline();
            tl.to(this.nodes.splash.screen, { opacity: 0, duration: 1, ease: 'power2.inOut', onComplete: () => this.nodes.splash.screen.style.display = 'none' })
              .set(this.nodes.app, { visibility: 'visible', opacity: 0 })
              .to(this.nodes.app, { opacity: 1, duration: 1.5, ease: 'power2.out' }, "-=0.5");
            this.nodes.viewfinder.width = this.nodes.video.videoWidth;
            this.nodes.viewfinder.height = this.nodes.video.videoHeight;
            this.contexts.viewfinder = this.nodes.viewfinder.getContext('2d', { willReadFrequently: true });
            this.setupScopes();
            this.startProcessingLoop();
        },
        
        startProcessingLoop() {
            if (this.state.animationFrameId) cancelAnimationFrame(this.state.animationFrameId);
            const loop = () => {
                if (!this.state.stream || this.nodes.video.paused || this.nodes.video.ended) return;
                
                this.contexts.viewfinder.drawImage(this.nodes.video, 0, 0, this.nodes.viewfinder.width, this.nodes.viewfinder.height);
                const imageData = this.contexts.viewfinder.getImageData(0, 0, this.nodes.viewfinder.width, this.nodes.viewfinder.height);

                if (this.worker) {
                    this.worker.postMessage({
                        type: 'processFrame',
                        payload: { imageData, logProfile: this.state.currentLogProfile }
                    }, [imageData.data.buffer]);
                } else { // Fallback if worker fails
                    const profile = this.logProfiles[this.state.currentLogProfile];
                    if (profile.b !== 0) this.applyLogTransform(imageData.data, profile.a, profile.b);
                    this.contexts.viewfinder.putImageData(imageData, 0, 0);
                    // this.updateScopes(imageData.data); // scope update would need to be re-implemented for non-worker
                }
                
                if (this.state.isRecording) this.updateTimecode();
                this.state.animationFrameId = requestAnimationFrame(loop);
            };
            this.state.animationFrameId = requestAnimationFrame(loop);
        },

        stopProcessingLoop() {
            if (this.state.animationFrameId) { cancelAnimationFrame(this.state.animationFrameId); this.state.animationFrameId = null; }
        },
        
        // [IV] === SCOPES & VISUALIZATION ===
        setupScopes() {
            ['histogram', 'waveform'].forEach(scope => {
                const canvas = this.nodes.scopes[scope]; canvas.width = 128; canvas.height = 96; this.contexts[scope] = canvas.getContext('2d');
            });
        },

        drawHistogram(bins) {
            const ctx = this.contexts.histogram;
            let maxBin = 0;
            for (let i = 0; i < 256; i++) { if (bins[i] > maxBin) maxBin = bins[i]; }
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = `rgba(0, 255, 255, 0.7)`;
            for (let i = 0; i < 256; i++) {
                const h = (bins[i] / maxBin) * ctx.canvas.height;
                const x = (i / 256) * ctx.canvas.width;
                const w = ctx.canvas.width / 256;
                ctx.fillRect(x, ctx.canvas.height - h, w, h);
            }
        },
        
        drawWaveform(densityData) {
            const ctx = this.contexts.waveform;
            const w = ctx.canvas.width; const h = ctx.canvas.height;
            ctx.clearRect(0, 0, w, h);
            const imgData = ctx.createImageData(w, h);
            for(let i=0; i < densityData.length; i++) {
                const d = densityData[i];
                if (d > 0) {
                    const bi = i * 4;
                    imgData.data[bi] = 0;
                    imgData.data[bi + 1] = Math.min(255, d * 8);
                    imgData.data[bi + 2] = Math.min(255, d * 8);
                    imgData.data[bi + 3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);
        },

        // [V] === RECORDING & STORAGE LOGIC ===
        toggleRecording() {
            if (!this.state.isRecording) {
                this.state.isRecording = true;
                this.state.recordedChunks = [];
                const canvasStream = this.nodes.viewfinder.captureStream(30);
                const audioTracks = this.state.stream.getAudioTracks();
                if (audioTracks.length > 0) canvasStream.addTrack(audioTracks[0].clone());
                
                let options = { mimeType: 'video/webm; codecs=vp9' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) options = { mimeType: 'video/webm; codecs=vp8' };
                
                this.state.mediaRecorder = new MediaRecorder(canvasStream, options);
                this.state.mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) this.state.recordedChunks.push(e.data); };
                this.state.mediaRecorder.onstop = () => this.saveRecordingToDB();
                this.state.mediaRecorder.start();
                this.state.recordingStartTime = Date.now();
                
                this.nodes.recIndicator.classList.add('recording');
                this.nodes.recIndicatorText.textContent = 'REC';
                this.nodes.controls.recordButton.classList.add('recording');
            } else {
                this.state.isRecording = false;
                if (this.state.mediaRecorder && this.state.mediaRecorder.state === 'recording') this.state.mediaRecorder.stop();
                this.nodes.recIndicator.classList.remove('recording');
                this.nodes.recIndicatorText.textContent = 'STANDBY';
                this.nodes.controls.recordButton.classList.remove('recording');
            }
        },

        saveRecordingToDB() {
            const videoBlob = new Blob(this.state.recordedChunks, { type: 'video/webm' });
            const metadata = {
                timestamp_utc: new Date().toISOString(), log_profile: this.logProfiles[this.state.currentLogProfile],
                resolution: { width: this.nodes.viewfinder.width, height: this.nodes.viewfinder.height }, engine: "CINE-LOG.OS v2.0"
            };
            const clip = { id: `cl-${Date.now()}`, video: videoBlob, meta: metadata, };
            
            const transaction = this.db.transaction(['clips'], 'readwrite');
            const store = transaction.objectStore('clips');
            const request = store.add(clip);
            
            request.onsuccess = () => { this.showNotification('Clip saved to database.', 'success'); };
            request.onerror = (e) => { this.showNotification('Failed to save clip.', 'error'); console.error('DB Save Error:', e); };
        },

        // [VI] === GALLERY LOGIC ===
        async openGallery() {
            this.nodes.gallery.clipsContainer.innerHTML = '';
            this.resetGalleryDetails();
            const clips = await this.getAllClipsFromDB();
            if (clips.length === 0) {
                this.nodes.gallery.clipsContainer.innerHTML = `<p style="color:var(--color-text-secondary); grid-column: 1/-1; text-align:center;">No clips in database.</p>`;
            } else {
                clips.forEach(clip => this.createClipCard(clip));
            }

            gsap.set(this.nodes.gallery.view, { visibility: 'visible' });
            gsap.to(this.nodes.gallery.view, { opacity: 1, duration: var(--transition-speed-med) });
            gsap.from(this.nodes.gallery.header, { y: -50, opacity: 0, duration: 0.5, ease: 'power2.out', delay: 0.1 });
            gsap.from(this.nodes.gallery.details, { x: 100, opacity: 0, duration: 0.5, ease: 'power2.out', delay: 0.2 });
            gsap.from(".clip-card", { scale: 0.8, opacity: 0, stagger: 0.05, duration: 0.4, ease: 'power2.out', delay: 0.3 });
        },

        closeGallery() {
            gsap.to(this.nodes.gallery.view, { opacity: 0, duration: var(--transition-speed-med), onComplete: () => {
                gsap.set(this.nodes.gallery.view, { visibility: 'hidden' });
            }});
        },

        getAllClipsFromDB() {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction(['clips'], 'readonly');
                const store = transaction.objectStore('clips');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result.reverse());
                request.onerror = (e) => reject(e);
            });
        },
        
        getClipFromDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction(['clips'], 'readonly');
                const store = transaction.objectStore('clips');
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result);
                request.onerror = e => reject(e);
            });
        },

        createClipCard(clip) {
            const card = document.createElement('div');
            card.className = 'clip-card';
            card.dataset.id = clip.id;
            const videoUrl = URL.createObjectURL(clip.video);
            card.innerHTML = `
                <video src="${videoUrl}" preload="metadata" muted loop onmouseover="this.play()" onmouseout="this.pause();this.currentTime=0;"></video>
                <div class="clip-info">${new Date(clip.meta.timestamp_utc).toLocaleString()}</div>
            `;
            this.nodes.gallery.clipsContainer.appendChild(card);
        },
        
        async selectGalleryClip(id) {
            this.state.selectedClipId = id;
            const clips = this.nodes.gallery.clipsContainer.querySelectorAll('.clip-card');
            clips.forEach(c => c.classList.toggle('selected', c.dataset.id === id));
            
            const clip = await this.getClipFromDB(id);
            if (!clip) return;

            this.state.selectedClipData = clip;
            const videoUrl = URL.createObjectURL(clip.video);
            this.nodes.gallery.playerContainer.innerHTML = `<video src="${videoUrl}" controls autoplay></video>`;
            this.nodes.gallery.metaDisplay.textContent = JSON.stringify(clip.meta, null, 2);
            
            [this.nodes.gallery.downloadVideoBtn, this.nodes.gallery.downloadMetaBtn, this.nodes.gallery.deleteClipBtn].forEach(btn => btn.disabled = false);
        },
        
        resetGalleryDetails() {
            this.state.selectedClipId = null;
            this.state.selectedClipData = null;
            this.nodes.gallery.playerContainer.innerHTML = '';
            this.nodes.gallery.metaDisplay.textContent = 'NO CLIP SELECTED';
            [this.nodes.gallery.downloadVideoBtn, this.nodes.gallery.downloadMetaBtn, this.nodes.gallery.deleteClipBtn].forEach(btn => btn.disabled = true);
        },

        downloadSelectedClip(type) {
            if (!this.state.selectedClipData) return;
            const { video, meta, id } = this.state.selectedClipData;
            const timestamp = meta.timestamp_utc.replace(/[:.]/g, '-');
            let blob, filename;
            if (type === 'video') {
                blob = video;
                filename = `CINE-LOG_${timestamp}.webm`;
            } else {
                blob = new Blob([JSON.stringify(meta, null, 2)], { type: 'application/json' });
                filename = `CINE-LOG_${timestamp}_meta.json`;
            }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        },

        deleteSelectedClip() {
            const id = this.state.selectedClipId;
            if (!id || !confirm("Are you sure you want to permanently delete this clip?")) return;
            
            const transaction = this.db.transaction(['clips'], 'readwrite');
            const store = transaction.objectStore('clips');
            const request = store.delete(id);
            
            request.onsuccess = () => {
                this.showNotification("Clip deleted.", "success");
                const card = this.nodes.gallery.clipsContainer.querySelector(`[data-id="${id}"]`);
                if (card) {
                    gsap.to(card, { opacity: 0, scale: 0.5, duration: 0.3, onComplete: () => {
                        card.remove();
                        this.resetGalleryDetails();
                    }});
                }
            };
            request.onerror = (e) => {
                this.showNotification("Failed to delete clip.", "error");
                console.error('DB Delete Error:', e);
            };
        },

        // [VII] === UTILITIES ===
        updateTimecode() {
            const e = Date.now() - this.state.recordingStartTime, s = Math.floor(e / 1000);
            const h=String(Math.floor(s/3600)).padStart(2,'0'), m=String(Math.floor((s%3600)/60)).padStart(2,'0'), sec=String(s%60).padStart(2,'0'), f=String(Math.floor((e%1000)/(1000/30))).padStart(2,'0');
            this.nodes.timecode.textContent = `${h}:${m}:${sec}:${f}`;
        },

        async updateBatteryStatus() {
            try {
                if ('getBattery' in navigator) {
                    const battery = await navigator.getBattery(); const level = Math.floor(battery.level * 100);
                    this.nodes.batteryStatus.textContent = `BATT ${level}%`; this.nodes.batteryStatus.style.color = level < 20 ? 'var(--color-accent-danger)' : 'var(--color-text-primary)';
                }
            } catch (err) { this.nodes.batteryStatus.textContent = `BATT N/A`; }
        },
        
        showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            this.nodes.notificationCenter.appendChild(notification);
            gsap.from(notification, { x: 100, opacity: 0, duration: 0.5, ease: 'power3.out' });
            gsap.to(notification, { opacity: 0, duration: 0.5, delay: 4, onComplete: () => notification.remove() });
        }
    };
    </script>
</body>
</html>
