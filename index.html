<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Project Chimera: Cinematic PWA</title>
    
    <style>
        :root{--primary-color:#ff4757;--secondary-color:#2f3640;--tertiary-color:#718093;--accent-color:#00a8ff;--text-color:#f5f6fa;--font-family:'SF Pro Display','Roboto',sans-serif;--transition-speed:0.3s}
        *,*::before,*::after{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent}
        html,body{width:100%;height:100%;overflow:hidden;background-color:#000;color:var(--text-color);font-family:var(--font-family);font-synthesis:none;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
        #app-container{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center;background:#000}
        #camera-feed{display:none}
        #main-canvas{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}
        #ui-overlay{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;justify-content:space-between;pointer-events:none;z-index:10}
        .ui-bar{width:100%;padding:15px 20px;display:flex;justify-content:space-between;align-items:center;background:linear-gradient(to bottom,rgba(0,0,0,0.7),rgba(0,0,0,0));pointer-events:all}
        .ui-bar.bottom{background:linear-gradient(to top,rgba(0,0,0,0.7),rgba(0,0,0,0));justify-content:center}
        #status-indicators{display:flex;gap:20px;align-items:center}
        .status-item{display:flex;align-items:center;gap:8px;font-size:14px;font-weight:600;letter-spacing:0.5px;text-shadow:0 1px 3px rgba(0,0,0,0.5)}
        #rec-indicator{color:var(--primary-color);opacity:0;transition:opacity var(--transition-speed) ease}
        #rec-indicator.recording{opacity:1;animation:pulse 1.5s infinite}
        @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.4}}
        #log-status.active{color:var(--accent-color);text-shadow:0 0 8px var(--accent-color)}
        #controls{display:flex;justify-content:space-around;align-items:center;width:100%;max-width:400px}
        .control-button{background:0 0;border:none;color:var(--text-color);cursor:pointer;padding:10px;border-radius:50%;display:flex;justify-content:center;align-items:center;transition:background-color var(--transition-speed) ease,transform var(--transition-speed) ease;pointer-events:all}
        .control-button:hover{background-color:rgba(255,255,255,0.1)}
        .control-button:active{transform:scale(0.9)}
        .control-button svg{width:28px;height:28px;filter:drop-shadow(0 1px 2px rgba(0,0,0,0.5))}
        #record-button{width:70px;height:70px;border:4px solid var(--text-color);background-color:transparent;position:relative}
        #record-button::before{content:'';position:absolute;width:85%;height:85%;background-color:var(--primary-color);border-radius:50%;transition:all var(--transition-speed) cubic-bezier(0.68,-0.55,0.27,1.55)}
        #record-button.recording::before{width:50%;height:50%;border-radius:10%;background-color:var(--primary-color)}
        #record-button:disabled{opacity:0.5;cursor:not-allowed}
        #gallery-modal{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(10,10,10,0.98);backdrop-filter:blur(10px);z-index:100;display:flex;flex-direction:column;transform:translateY(100%);transition:transform .5s cubic-bezier(0.16,1,0.3,1);pointer-events:none;opacity:0}
        #gallery-modal.open{transform:translateY(0);pointer-events:all;opacity:1}
        #gallery-header{padding:20px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--secondary-color)}
        #gallery-header h2{font-size:24px;font-weight:600}
        #gallery-grid{flex-grow:1;overflow-y:auto;padding:20px;display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:15px}
        .gallery-item{aspect-ratio:9/16;background-color:var(--secondary-color);border-radius:8px;overflow:hidden;position:relative;cursor:pointer}
        .gallery-item video{width:100%;height:100%;object-fit:cover}
        .gallery-item-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to top,rgba(0,0,0,0.8),transparent);display:flex;flex-direction:column;justify-content:space-between;padding:8px}
        .gallery-item-actions{display:flex;justify-content:space-between;align-items:center}
        .gallery-item-actions button{background-color:rgba(0,0,0,0.7);border:none;color:#fff;border-radius:50%;width:30px;height:30px;cursor:pointer;display:flex;align-items:center;justify-content:center}
        .gallery-item-actions button svg{width:16px;height:16px}
        .video-info{font-size:12px;text-align:left;text-shadow:0 1px 2px #000}
        #video-player-modal{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#000;z-index:110;display:none;justify-content:center;align-items:center}
        #video-player-modal video{max-width:100%;max-height:100%}
        #video-player-modal .close-player{position:absolute;top:20px;right:20px;font-size:30px;color:#fff;background:0 0;border:none;cursor:pointer}
        #loading-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#000;z-index:200;display:flex;justify-content:center;align-items:center;flex-direction:column;transition:opacity .5s ease;text-align:center;padding:20px}
        .spinner{width:50px;height:50px;border:4px solid var(--secondary-color);border-top-color:var(--accent-color);border-radius:50%;animation:spin 1s linear infinite}
        #loading-text{margin-top:20px;color:var(--tertiary-color)}
        @keyframes spin{to{transform:rotate(360deg)}}
    </style>
</head>
<body>
    <div id="app-container">
        <video id="camera-feed" playsinline autoplay muted></video>
        <canvas id="main-canvas"></canvas>
        <div id="ui-overlay">
            <div class="ui-bar top">
                <div id="status-indicators">
                    <div id="rec-indicator" class="status-item">
                        <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><circle cx="12" cy="12" r="8"></circle></svg>
                        <span>REC</span>
                    </div>
                    <div id="log-status" class="status-item">LOG</div>
                    <div id="resolution-status" class="status-item">...</div>
                </div>
            </div>
            <div class="ui-bar bottom">
                <div id="controls">
                    <button id="gallery-button" class="control-button" aria-label="Open Gallery"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 3H4c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h16c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2zM4 19V5h16l.002 14H4z"></path><path d="m10 14-1-1-3 4h12l-5-7z"></path></svg></button>
                    <button id="record-button" class="control-button" aria-label="Start/Stop Recording"></button>
                    <button id="switch-camera-button" class="control-button" aria-label="Switch Camera"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16.75 2h-10c-1.103 0-2 .897-2 2v16c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zm-10 20V4h10l.002 16H6.75z"></path><path d="M12 18a4 4 0 1 0 0-8 4 4 0 0 0 0 8zm0-6a2 2 0 1 1 0 4 2 2 0 0 1 0-4zM16 7H8V5h8v2z"></path></svg></button>
                </div>
            </div>
        </div>
        <button id="log-toggle-button" class="control-button" style="position:absolute;bottom:120px;left:20px;z-index:11;background-color:rgba(0,0,0,0.3);backdrop-filter:blur(5px);">LOG</button>
    </div>
    <div id="gallery-modal">
        <div id="gallery-header">
            <h2>Vault</h2>
            <button id="close-gallery-button" class="control-button" aria-label="Close Gallery"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path d="M19.071 4.929 4.929 19.071m4.929-14.142 14.142 14.142" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
        </div>
        <div id="gallery-grid"><p id="no-recordings-message">No recordings yet. Create something monumental.</p></div>
    </div>
    <div id="video-player-modal"><video id="gallery-video-player" controls></video><button class="close-player">&times;</button></div>
    <div id="loading-overlay"><div class="spinner"></div><p id="loading-text">Calibrating Pseudo-Sensor...</p></div>

    <!-- SHADERS (unchanged, pure logic) -->
    <script id="vertex-shader" type="x-shader/x-vertex">attribute vec2 a_position;attribute vec2 a_texCoord;varying vec2 v_texCoord;void main(){gl_Position=vec4(a_position,0.0,1.0);v_texCoord=a_texCoord;}</script>
    <script id="fragment-shader" type="x-shader/x-fragment">precision highp float;uniform sampler2D u_texture;uniform bool u_log_enabled;uniform vec2 u_resolution;uniform float u_time;varying vec2 v_texCoord;float hash(vec2 p){return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);}vec3 rec709ToLinear(vec3 c){return pow(c,vec3(2.2));}vec3 linearToSLog3(vec3 c){return pow(c,vec3(1.0/2.6));}vec3 applyAIDelta(vec3 c){float grain=(hash(v_texCoord+u_time)-0.5)*0.03;c+=grain;vec2 o=1.0/u_resolution;vec3 b=texture2D(u_texture,v_texCoord-o).rgb+texture2D(u_texture,v_texCoord+o).rgb+texture2D(u_texture,v_texCoord+vec2(-o.x,o.y)).rgb+texture2D(u_texture,v_texCoord+vec2(o.x,-o.y)).rgb;b/=4.0;c=mix(b,c,1.2);return c;}void main(){vec3 o=texture2D(u_texture,v_texCoord).rgb;if(u_log_enabled){vec3 l=rec709ToLinear(o);vec3 le=linearToSLog3(l);vec3 f=applyAIDelta(le);gl_FragColor=vec4(clamp(f,0.0,1.0),1.0);}else{gl_FragColor=vec4(o,1.0);}}</script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            const APP_STATE = {
                isRecording: false, stream: null, mediaRecorder: null, recordedChunks: [], facingMode: 'environment', isLogEnabled: false, supportedMimeType: '', stopRecordingPromise: null, gl: null, glProgram: null, videoTexture: null,
                renderer: { positionBuffer: null, texCoordBuffer: null, locations: {} }
            };

            const DOM = { video: document.getElementById('camera-feed'), canvas: document.getElementById('main-canvas'), recordButton: document.getElementById('record-button'), switchCameraButton: document.getElementById('switch-camera-button'), galleryButton: document.getElementById('gallery-button'), logToggleButton: document.getElementById('log-toggle-button'), recIndicator: document.getElementById('rec-indicator'), logStatus: document.getElementById('log-status'), resolutionStatus: document.getElementById('resolution-status'), galleryModal: document.getElementById('gallery-modal'), closeGalleryButton: document.getElementById('close-gallery-button'), galleryGrid: document.getElementById('gallery-grid'), loadingOverlay: document.getElementById('loading-overlay'), loadingText: document.getElementById('loading-text'), videoPlayerModal: document.getElementById('video-player-modal'), galleryVideoPlayer: document.getElementById('gallery-video-player'), closePlayerButton: document.querySelector('.close-player') };

            const Utils = {
                findSupportedMimeType: function() { const c = ['video/mp4; codecs="avc1.42E01E, mp4a.40.2"','video/webm; codecs=vp9,opus','video/webm; codecs=vp8,opus','video/webm']; for(const t of c) if(MediaRecorder.isTypeSupported(t)) return t; return ''; },
                // [NEW] Helper for downloading blobs
                downloadBlob: function(blob, timestamp) {
                    const extension = (blob.type.includes('mp4')) ? 'mp4' : 'webm';
                    const filename = `Chimera-Capture-${timestamp}.${extension}`;
                    const a = document.createElement('a');
                    document.body.appendChild(a);
                    a.style.display = 'none';
                    const url = window.URL.createObjectURL(blob);
                    a.href = url;
                    a.download = filename;
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                }
            };
            const astraDB = (()=>{let d;const n="ProjectChimeraDB",o="recordings";function i(){return new Promise((e,t)=>{const r=indexedDB.open(n,1);r.onerror=e=>t("IndexedDB error: "+e.target.errorCode),r.onsuccess=e=>{d=e.target.result,e()},r.onupgradeneeded=e=>{e.target.result.createObjectStore(o,{keyPath:"id",autoIncrement:!0})}})}function c(e){return new Promise((t,r)=>{const s=d.transaction([o],"readwrite").objectStore(o).add({blob:e,timestamp:(new Date).toISOString(),size:e.size});s.onsuccess=t,s.onerror=r})}function a(){return new Promise((e,t)=>{const r=d.transaction([o],"readonly").objectStore(o).getAll();r.onsuccess=t=>e(t.target.result.reverse()),r.onerror=t})}function e(e){return new Promise((t,r)=>{const s=d.transaction([o],"readwrite").objectStore(o).delete(e);s.onsuccess=t,s.onerror=r})}return{init:i,saveVideo:c,getAllVideos:a,deleteVideo:e}})();
            const webGLRenderer = (()=>{function i(){return APP_STATE.gl=DOM.canvas.getContext("webgl",{antialias:!1,powerPreference:"high-performance"}),!!APP_STATE.gl&&(APP_STATE.glProgram=function(e,t,r){const n=function(e,t,r){const n=e.createShader(t);if(e.shaderSource(n,r),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))return console.error("Shader compile error: "+e.getShaderInfoLog(n)),e.deleteShader(n),null;return n}(e,e.VERTEX_SHADER,t),o=function(e,t,r){const n=e.createShader(t);if(e.shaderSource(n,r),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))return console.error("Shader compile error: "+e.getShaderInfoLog(n)),e.deleteShader(n),null;return n}(e,e.FRAGMENT_SHADER,r);if(!n||!o)return null;const c=e.createProgram();if(e.attachShader(c,n),e.attachShader(c,o),e.linkProgram(c),!e.getProgramParameter(c,e.LINK_STATUS))return console.error("Program link error: "+e.getProgramInfoLog(c)),null;return c}(APP_STATE.gl,document.getElementById("vertex-shader").text,document.getElementById("fragment-shader").text),APP_STATE.renderer.locations={position:APP_STATE.gl.getAttribLocation(APP_STATE.glProgram,"a_position"),texCoord:APP_STATE.gl.getAttribLocation(APP_STATE.glProgram,"a_texCoord"),texture:APP_STATE.gl.getUniformLocation(APP_STATE.glProgram,"u_texture"),logEnabled:APP_STATE.gl.getUniformLocation(APP_STATE.glProgram,"u_log_enabled"),resolution:APP_STATE.gl.getUniformLocation(APP_STATE.glProgram,"u_resolution"),time:APP_STATE.gl.getUniformLocation(APP_STATE.glProgram,"u_time")},function(e){const t=[-1,1,1,1,-1,-1,1,-1],r=[0,0,1,0,0,1,1,1];APP_STATE.renderer.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,APP_STATE.renderer.positionBuffer),e.bufferData(e.ARRAY_BUFFER,new Float32Array(t),e.STATIC_DRAW),APP_STATE.renderer.texCoordBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,APP_STATE.renderer.texCoordBuffer),e.bufferData(e.ARRAY_BUFFER,new Float32Array(r),e.STATIC_DRAW)}(APP_STATE.gl),function(e){APP_STATE.videoTexture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,APP_STATE.videoTexture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR)}(APP_STATE.gl),!0)}function c(e){requestAnimationFrame(c),APP_STATE.stream&&!DOM.video.paused&&!DOM.video.ended&&(function(e){e.bindTexture(e.TEXTURE_2D,APP_STATE.videoTexture),DOM.video.readyState>=DOM.video.HAVE_CURRENT_DATA&&e.texImage2D(e.TEXTURE_2D,0,e.RGB,e.RGB,e.UNSIGNED_BYTE,DOM.video)}(APP_STATE.gl),APP_STATE.gl.viewport(0,0,APP_STATE.gl.canvas.width,APP_STATE.gl.canvas.height),APP_STATE.gl.clearColor(0,0,0,1),APP_STATE.gl.clear(APP_STATE.gl.COLOR_BUFFER_BIT),APP_STATE.gl.useProgram(APP_STATE.glProgram),APP_STATE.gl.bindBuffer(APP_STATE.gl.ARRAY_BUFFER,APP_STATE.renderer.positionBuffer),APP_STATE.gl.enableVertexAttribArray(APP_STATE.renderer.locations.position),APP_STATE.gl.vertexAttribPointer(APP_STATE.renderer.locations.position,2,APP_STATE.gl.FLOAT,!1,0,0),APP_STATE.gl.bindBuffer(APP_STATE.gl.ARRAY_BUFFER,APP_STATE.renderer.texCoordBuffer),APP_STATE.gl.enableVertexAttribArray(APP_STATE.renderer.locations.texCoord),APP_STATE.gl.vertexAttribPointer(APP_STATE.renderer.locations.texCoord,2,APP_STATE.gl.FLOAT,!1,0,0),APP_STATE.gl.uniform1i(APP_STATE.renderer.locations.texture,0),APP_STATE.gl.uniform1i(APP_STATE.renderer.locations.logEnabled,APP_STATE.isLogEnabled),APP_STATE.gl.uniform2f(APP_STATE.renderer.locations.resolution,APP_STATE.gl.canvas.width,APP_STATE.gl.canvas.height),APP_STATE.gl.uniform1f(APP_STATE.renderer.locations.time,e/1e3),APP_STATE.gl.activeTexture(APP_STATE.gl.TEXTURE0),APP_STATE.gl.bindTexture(APP_STATE.gl.TEXTURE_2D,APP_STATE.videoTexture),APP_STATE.gl.drawArrays(APP_STATE.gl.TRIANGLE_STRIP,0,4))}return{init:i,render:c}})();

            const cameraController = (function() {
                async function negotiateStream(facingMode) {
                    const cascade = [{v:{fm:facingMode,w:{i:1920},h:{i:1080}}},{v:{fm:facingMode,w:{i:1280},h:{i:720}}},{v:{fm:facingMode}},{v:true}];
                    for(let c of cascade) try { return await navigator.mediaDevices.getUserMedia({video: {facingMode:c.v.fm, width:c.v.w, height:c.v.h}, audio: true}); } catch(e) {}
                    throw new Error("Could not acquire any camera stream.");
                }

                async function start() {
                    try {
                        if (APP_STATE.stream) APP_STATE.stream.getTracks().forEach(t => t.stop());
                        DOM.loadingText.textContent = 'Negotiating with hardware...';
                        APP_STATE.stream = await negotiateStream(APP_STATE.facingMode);
                        DOM.video.srcObject = APP_STATE.stream;
                        DOM.video.onloadedmetadata = () => {
                            const s = APP_STATE.stream.getVideoTracks()[0].getSettings();
                            DOM.resolutionStatus.textContent = `${s.height}p${Math.round(s.frameRate || 30)}`;
                            DOM.canvas.width = DOM.video.videoWidth; DOM.canvas.height = DOM.video.videoHeight;
                            DOM.loadingOverlay.style.opacity = '0'; DOM.loadingOverlay.style.pointerEvents = 'none';
                        };
                    } catch (err) {
                        DOM.loadingText.textContent = `Error: ${err.message}. Please check permissions.`;
                    }
                }

                function switchCamera() { APP_STATE.facingMode = APP_STATE.facingMode === 'user' ? 'environment' : 'user'; start(); }

                function startRecording() {
                    if (!APP_STATE.stream || APP_STATE.isRecording) return;
                    if (!APP_STATE.supportedMimeType) { alert("Recording not supported."); return; }
                    
                    APP_STATE.recordedChunks = [];
                    const stream = DOM.canvas.captureStream(30);
                    if (APP_STATE.stream.getAudioTracks()[0]) stream.addTrack(APP_STATE.stream.getAudioTracks()[0].clone());
                    
                    try { APP_STATE.mediaRecorder = new MediaRecorder(stream, { mimeType: APP_STATE.supportedMimeType, videoBitsPerSecond: 15000000 }); } 
                    catch (e) { console.error("MediaRecorder failed:", e); return; }

                    // [THE FIX - Part 1] Establish the promise lock.
                    let resolveStopPromise;
                    APP_STATE.stopRecordingPromise = new Promise(resolve => { resolveStopPromise = resolve; });

                    APP_STATE.mediaRecorder.ondataavailable = e => { if (e.data.size > 0) APP_STATE.recordedChunks.push(e.data); };
                    
                    // [THE FIX - Part 2] The onstop event handler is now the key that unlocks the promise.
                    APP_STATE.mediaRecorder.onstop = async () => {
                        const completeBlob = new Blob(APP_STATE.recordedChunks, { type: APP_STATE.supportedMimeType });
                        if (completeBlob.size === 0) {
                            console.error("Recording resulted in an empty file. Aborting save.");
                            resolveStopPromise(); // Resolve to unblock UI even on failure
                            return;
                        }
                        await astraDB.saveVideo(completeBlob);
                        APP_STATE.recordedChunks = [];
                        resolveStopPromise(); // Fulfill the promise *after* saving is complete.
                    };

                    APP_STATE.mediaRecorder.start();
                    updateUIForRecording(true);
                }

                async function stopRecording() {
                    // [THE FIX - Part 3] The stop command now awaits the promise lock.
                    if (!APP_STATE.mediaRecorder || APP_STATE.mediaRecorder.state !== 'recording') return;
                    
                    DOM.recordButton.disabled = true; // Prevent interaction during finalization
                    DOM.recIndicator.textContent = 'SAVING...';

                    APP_STATE.mediaRecorder.requestData();
                    APP_STATE.mediaRecorder.stop();

                    // This await is the core of the fix. It pauses execution here until the 'onstop' handler has fully completed.
                    await APP_STATE.stopRecordingPromise;
                    
                    console.log("Finalization complete. UI unlocked.");
                    DOM.recIndicator.textContent = 'REC';
                    DOM.recordButton.disabled = false;
                    updateUIForRecording(false);
                    populateGallery();
                }
                
                return { start, switchCamera, startRecording, stopRecording };
            })();

            function setupEventListeners() { DOM.recordButton.addEventListener('click', () => { APP_STATE.isRecording ? cameraController.stopRecording() : cameraController.startRecording(); }); DOM.switchCameraButton.addEventListener('click', cameraController.switchCamera); DOM.logToggleButton.addEventListener('click', toggleLogMode); DOM.galleryButton.addEventListener('click', openGallery); DOM.closeGalleryButton.addEventListener('click', closeGallery); DOM.closePlayerButton.addEventListener('click', closeVideoPlayer); }
            function updateUIForRecording(isRecording) { APP_STATE.isRecording = isRecording; DOM.recordButton.classList.toggle('recording', isRecording); DOM.recIndicator.classList.toggle('recording', isRecording); }
            function toggleLogMode() { APP_STATE.isLogEnabled = !APP_STATE.isLogEnabled; DOM.logStatus.classList.toggle('active', APP_STATE.isLogEnabled); }
            
            async function populateGallery() {
                const videos = await astraDB.getAllVideos();
                DOM.galleryGrid.innerHTML = '';
                if (videos.length === 0) { DOM.galleryGrid.innerHTML = '<p id="no-recordings-message">No recordings yet.</p>'; return; }
                
                videos.forEach(videoData => {
                    const item = document.createElement('div');
                    item.className = 'gallery-item';
                    
                    const videoEl = document.createElement('video');
                    videoEl.src = URL.createObjectURL(videoData.blob);
                    videoEl.muted = true;
                    videoEl.preload = 'metadata';

                    const overlay = document.createElement('div');
                    overlay.className = 'gallery-item-overlay';
                    
                    const info = document.createElement('div');
                    info.className = 'video-info';
                    info.innerHTML = `<span>${new Date(videoData.timestamp).toLocaleString()}</span><br><span>${(videoData.size / 1024 / 1024).toFixed(2)} MB</span>`;
                    
                    // [NEW] Action buttons for delete and download
                    const actions = document.createElement('div');
                    actions.className = 'gallery-item-actions';

                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg>';
                    deleteBtn.onclick = async e => { e.stopPropagation(); if (confirm('Delete recording?')) { await astraDB.deleteVideo(videoData.id); item.remove(); } };
                    
                    const downloadBtn = document.createElement('button');
                    downloadBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></svg>';
                    downloadBtn.onclick = e => { e.stopPropagation(); Utils.downloadBlob(videoData.blob, videoData.timestamp); };

                    actions.appendChild(downloadBtn);
                    actions.appendChild(deleteBtn);
                    overlay.appendChild(actions);
                    overlay.appendChild(info);
                    item.appendChild(videoEl);
                    item.appendChild(overlay);
                    item.onclick = () => playVideoInModal(videoEl.src);
                    DOM.galleryGrid.appendChild(item);
                });
            }

            function openGallery() { populateGallery(); DOM.galleryModal.classList.add('open'); }
            function closeGallery() { DOM.galleryModal.classList.remove('open'); }
            function playVideoInModal(url) { DOM.galleryVideoPlayer.src = url; DOM.videoPlayerModal.style.display = 'flex'; DOM.galleryVideoPlayer.play(); }
            function closeVideoPlayer() { DOM.galleryVideoPlayer.pause(); DOM.galleryVideoPlayer.src = ''; DOM.videoPlayerModal.style.display = 'none'; }
            
            async function main() {
                setupEventListeners();
                APP_STATE.supportedMimeType = Utils.findSupportedMimeType();
                await astraDB.init();
                if (!webGLRenderer.init()) return;
                await cameraController.start();
                webGLRenderer.render();
            }

            main();
        });
    </script>
</body>
</html>
