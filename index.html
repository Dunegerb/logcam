<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CINE-LOG.WEB v2.0 | Multi-Threaded Real-time LOG Video Pipeline</title>
    <meta name="description" content="A monumental in-browser application for real-time LOG video recording and processing, architected with a non-blocking multi-threaded pipeline for unparalleled performance and a complete media management system. A testament to the absolute limits of web engineering.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;700&family=Teko:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <style>
        /* [1] === CORE RESET & THEME ARCHITECTURE === */
        :root {
            --color-background: #000000;
            --color-primary-dark: #0a0a0a;
            --color-primary-medium: #111111;
            --color-primary-light: #1a1a1a;
            --color-accent: #00ffff;
            --color-accent-secondary: #ff00ff;
            --color-accent-danger: #ff4141;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #8a8a8a;
            --font-primary: 'Teko', sans-serif;
            --font-secondary: 'Roboto Mono', monospace;
            --transition-speed-fast: 0.3s;
            --transition-speed-medium: 0.6s;
            --transition-speed-slow: 1s;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background-color: var(--color-background); color: var(--color-text-primary); font-family: var(--font-secondary); font-size: 10px; -webkit-tap-highlight-color: transparent; user-select: none; }

        /* [2] === SPLASH SCREEN / BOOT SEQUENCE === */
        #splash-screen { position: fixed; inset: 0; background: var(--color-background); z-index: 10000; display: flex; justify-content: center; align-items: center; flex-direction: column; color: var(--color-accent); }
        #splash-logo { font-family: var(--font-primary); font-size: 8rem; font-weight: 600; letter-spacing: 4px; opacity: 0; transform: translateY(20px); }
        #splash-logo span { color: var(--color-text-primary); font-weight: 300; }
        #progress-bar-container { width: 80%; max-width: 400px; height: 2px; background: rgba(0, 255, 255, 0.2); margin-top: 2rem; opacity: 0; }
        #progress-bar { width: 0%; height: 100%; background: var(--color-accent); }
        #splash-status { margin-top: 1.5rem; font-size: 1.4rem; letter-spacing: 1px; opacity: 0; text-transform: uppercase; }

        /* [3] === MAIN APPLICATION INTERFACE === */
        #app-container { position: fixed; inset: 0; visibility: hidden; opacity: 0; background: var(--color-primary-dark); }
        #video-viewfinder { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
        #video-element { display: none; }
        
        /* [4] === HEADS-UP DISPLAY (HUD) & OVERLAYS === */
        .hud { position: absolute; inset: 0; pointer-events: none; display: grid; grid-template-rows: 60px 1fr 120px; grid-template-columns: 150px 1fr 150px; }
        .hud-element { padding: 1rem; color: var(--color-text-primary); font-size: 1.2rem; text-shadow: 0 0 5px rgba(0,0,0,0.7); }
        #status-bar { grid-column: 1 / 4; grid-row: 1 / 2; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent); padding: 1rem 2rem; }
        #rec-indicator { display: flex; align-items: center; font-weight: 700; font-size: 1.8rem; letter-spacing: 2px; color: var(--color-text-secondary); transition: color var(--transition-speed-fast); }
        #rec-indicator.recording { color: var(--color-accent-danger); }
        #rec-indicator .dot { width: 10px; height: 10px; background-color: currentColor; border-radius: 50%; margin-right: 8px; animation: pulse-animation 1.5s infinite; opacity: 0; transition: opacity var(--transition-speed-fast); }
        #rec-indicator.recording .dot { opacity: 1; }
        @keyframes pulse-animation { 0% { transform: scale(1); } 50% { transform: scale(0.8); } 100% { transform: scale(1); } }
        #timecode { font-size: 1.8rem; font-weight: 700; }
        #battery-status { font-size: 1.4rem; }
        
        #scopes-panel { grid-column: 1 / 2; grid-row: 2 / 3; display: flex; flex-direction: column; gap: 1rem; padding-left: 1rem; }
        .scope-container { background: rgba(10, 10, 10, 0.7); border: 1px solid var(--color-primary-light); border-radius: 4px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); padding: 0.5rem; }
        .scope-container h3 { font-family: var(--font-primary); font-size: 1.6rem; font-weight: 400; color: var(--color-accent); margin-bottom: 0.5rem; text-align: center; }
        .scope-canvas { width: 100%; aspect-ratio: 4/3; }
        
        #control-panel { grid-column: 3 / 4; grid-row: 2 / 3; display: flex; flex-direction: column; gap: 1.5rem; padding-right: 1rem; pointer-events: all; }
        .control-group { background: rgba(10, 10, 10, 0.7); border: 1px solid var(--color-primary-light); border-radius: 4px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); padding: 1rem; }
        .control-group label { display: block; font-family: var(--font-primary); font-size: 1.6rem; color: var(--color-accent); margin-bottom: 0.8rem; }
        .control-group select, .control-group input { width: 100%; background: var(--color-primary-medium); border: 1px solid var(--color-primary-light); color: var(--color-text-primary); font-family: var(--font-secondary); padding: 0.5rem; border-radius: 2px; font-size: 1.2rem; }
        
        #action-bar { grid-column: 1 / 4; grid-row: 3 / 4; display: flex; justify-content: center; align-items: center; gap: 3rem; background: linear-gradient(to top, rgba(0,0,0,0.6), transparent); pointer-events: all; }
        .action-button { width: 50px; height: 50px; background: var(--color-primary-medium); border: 2px solid var(--color-text-secondary); border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all var(--transition-speed-fast) ease; position: relative; }
        .action-button:hover { border-color: var(--color-accent); }
        .action-button svg { width: 24px; height: 24px; fill: var(--color-text-primary); transition: fill var(--transition-speed-fast) ease; }
        .action-button:hover svg { fill: var(--color-accent); }
        #gallery-button-counter { position: absolute; top: -5px; right: -5px; background: var(--color-accent); color: var(--color-background); font-size: 1.2rem; font-weight: bold; width: 20px; height: 20px; border-radius: 50%; display: flex; justify-content: center; align-items: center; transform: scale(0); transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #gallery-button-counter.visible { transform: scale(1); }
        
        #record-button { width: 70px; height: 70px; background: var(--color-primary-dark); border: 4px solid var(--color-text-secondary); border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all var(--transition-speed-fast) ease; }
        #record-button .inner-circle { width: 80%; height: 80%; background: var(--color-accent-danger); border-radius: 50%; transition: all var(--transition-speed-fast) ease; }
        #record-button.recording { border-color: var(--color-accent-danger); }
        #record-button.recording .inner-circle { border-radius: 15%; transform: scale(0.8); }
        
        /* [5] === MODALS / DIALOGS === */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 10001; display: flex; justify-content: center; align-items: center; padding: 2rem; display: none; opacity: 0; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); }
        .dialog-content { background: var(--color-primary-dark); border: 1px solid var(--color-accent); padding: 3rem; max-width: 500px; text-align: center; transform: scale(0.95); transition: transform var(--transition-speed-medium) cubic-bezier(0.165, 0.84, 0.44, 1); }
        .modal-overlay.visible .dialog-content { transform: scale(1); }
        .dialog-content h2 { font-family: var(--font-primary); font-size: 3rem; color: var(--color-accent); margin-bottom: 1.5rem; }
        .dialog-content p { font-size: 1.4rem; line-height: 1.6; margin-bottom: 2rem; color: var(--color-text-secondary); }
        .dialog-button { background: var(--color-accent); color: var(--color-background); border: none; padding: 1rem 3rem; font-family: var(--font-secondary); font-size: 1.6rem; font-weight: 700; cursor: pointer; transition: all var(--transition-speed-fast); }
        .dialog-button:hover { opacity: 0.8; }
        
        /* [6] === GALLERY MODAL === */
        #gallery-modal .dialog-content { max-width: 90vw; width: 100%; height: 90vh; display: flex; flex-direction: column; padding: 1.5rem; }
        #gallery-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding: 0 1rem; }
        #gallery-grid { flex-grow: 1; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; padding: 1rem; }
        .gallery-item { position: relative; aspect-ratio: 16/9; cursor: pointer; overflow: hidden; border-radius: 4px; border: 2px solid transparent; transition: border-color var(--transition-speed-fast); }
        .gallery-item:hover { border-color: var(--color-accent); }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; }
        .gallery-item-info { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.8), transparent); padding: 1rem; font-size: 1.1rem; }
        #gallery-empty-message { flex-grow: 1; display: flex; justify-content: center; align-items: center; color: var(--color-text-secondary); font-size: 2rem; }
        
        #gallery-player-view { position: absolute; inset: 0; background: var(--color-background); z-index: 10002; display: flex; flex-direction: column; visibility: hidden; opacity: 0; }
        #gallery-player-view video { width: 100%; height: calc(100% - 60px); object-fit: contain; }
        #gallery-player-controls { height: 60px; background: var(--color-primary-dark); display: flex; justify-content: center; align-items: center; gap: 2rem; }
        .player-button { background: var(--color-primary-light); color: var(--color-accent); border: 1px solid var(--color-accent); padding: 0.8rem 2rem; font-size: 1.4rem; cursor: pointer; transition: all var(--transition-speed-fast); }
        .player-button.danger { color: var(--color-accent-danger); border-color: var(--color-accent-danger); }
        .player-button:hover { opacity: 0.8; }
    </style>
</head>
<body>
    <div id="splash-screen">
        <div id="splash-logo">CINE-LOG<span>.WEB v2</span></div>
        <div id="progress-bar-container"><div id="progress-bar"></div></div>
        <div id="splash-status">INITIALIZING KERNEL</div>
    </div>

    <div id="app-container">
        <video id="video-element" playsinline autoplay muted></video>
        <canvas id="video-viewfinder"></canvas>
        <div class="hud">
            <!-- STATUS BAR (TOP) -->
            <div id="status-bar" class="hud-element">
                <div id="rec-indicator"><div class="dot"></div><span>STANDBY</span></div>
                <div id="timecode">00:00:00:00</div>
                <div id="battery-status">BATT --%</div>
            </div>
            <!-- SCOPES (LEFT) -->
            <div id="scopes-panel" class="hud-element">
                <div class="scope-container"><h3>LUMA HISTOGRAM</h3><canvas id="histogram-canvas" class="scope-canvas"></canvas></div>
                <div class="scope-container"><h3>LUMA WAVEFORM</h3><canvas id="waveform-canvas" class="scope-canvas"></canvas></div>
            </div>
            <!-- CONTROLS (RIGHT) -->
            <div id="control-panel" class="hud-element">
                <div class="control-group">
                    <label for="camera-select">CAMERA</label>
                    <select id="camera-select"></select>
                </div>
                <div class="control-group">
                    <label for="resolution-select">RESOLUTION</label>
                    <select id="resolution-select">
                        <option value="1080p">1920x1080</option>
                        <option value="720p" selected>1280x720</option>
                        <option value="480p">640x480</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="log-profile-select">LOG PROFILE</label>
                    <select id="log-profile-select">
                        <option value="weblog">WEB-LOG (Generic)</option>
                        <option value="clog">CINE-LOG (High DR)</option>
                        <option value="slog">SAT-LOG (Punchy)</option>
                        <option value="linear">LINEAR (No LOG)</option>
                    </select>
                </div>
            </div>
            <!-- ACTIONS (BOTTOM) -->
            <div id="action-bar" class="hud-element">
                <div id="gallery-button" class="action-button">
                    <svg viewBox="0 0 24 24"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zM11 12l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"/></svg>
                    <div id="gallery-button-counter">0</div>
                </div>
                <div id="record-button"><div class="inner-circle"></div></div>
                <div style="width: 50px; height: 50px;"></div> <!-- Spacer for balance -->
            </div>
        </div>
    </div>
    
    <!-- MODALS -->
    <div id="permission-dialog" class="modal-overlay">
        <div class="dialog-content">
            <h2>ACCESS REQUIRED</h2>
            <p>CINE-LOG.WEB requires access to your device's camera to initiate the real-time processing pipeline.</p>
            <button id="grant-permission-button" class="dialog-button">GRANT ACCESS</button>
        </div>
    </div>

    <div id="gallery-modal" class="modal-overlay">
        <div class="dialog-content">
            <div id="gallery-header">
                <h2>MEDIA BAY</h2>
                <button id="close-gallery-button" class="dialog-button">CLOSE</button>
            </div>
            <div id="gallery-grid"></div>
            <div id="gallery-empty-message">NO CLIPS RECORDED</div>
            <div id="gallery-player-view">
                <video id="gallery-player-video" controls></video>
                <div id="gallery-player-controls">
                    <button id="player-download-button" class="player-button">DOWNLOAD</button>
                    <button id="player-delete-button" class="player-button danger">DELETE</button>
                    <button id="player-close-button" class="player-button">BACK TO GALLERY</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- WEB WORKER SCRIPT -->
    <script id="processing-worker" type="javascript/worker">
    let logProfiles = {};

    function applyLogTransform(data, a, b) {
        for (let i = 0; i < data.length; i += 4) {
            const r_lin = data[i] / 255, g_lin = data[i + 1] / 255, b_lin = data[i + 2] / 255;
            const r_log = a * Math.log10(b * r_lin + 1.0), g_log = a * Math.log10(b * g_lin + 1.0), b_log = a * Math.log10(b * b_lin + 1.0);
            data[i] = Math.min(255, r_log * 255); data[i + 1] = Math.min(255, g_log * 255); data[i + 2] = Math.min(255, b_log * 255);
        }
    }
    
    function calculateScopes(data, width, height) {
        const histogramBins = new Uint32Array(256).fill(0);
        const SCOPE_W = 128, SCOPE_H = 96;
        const waveformDensity = new Uint16Array(SCOPE_W * SCOPE_H).fill(0);
        
        for (let i = 0; i < data.length; i += 4) {
            const luma = Math.round(0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2]);
            histogramBins[luma]++;
            
            // For waveform, we process based on original pixel position
            const pixelIndex = i / 4;
            const x = pixelIndex % width;
            const wx = Math.floor((x / width) * SCOPE_W);
            const wy = Math.floor(SCOPE_H - 1 - (luma / 255) * (SCOPE_H - 1));
            const idx = wy * SCOPE_W + wx;
            if (waveformDensity[idx] < 65535) waveformDensity[idx] += 8;
        }
        
        return { histogramBins, waveformDensity };
    }

    self.onmessage = (e) => {
        const { imageData, logProfileId, width, height } = e.data;
        if (e.data.type === 'init') {
            logProfiles = e.data.logProfiles;
            return;
        }

        const profile = logProfiles[logProfileId];
        if (profile.b !== 0) {
            applyLogTransform(imageData.data, profile.a, profile.b);
        }
        
        const scopes = calculateScopes(imageData.data, width, height);
        
        self.postMessage({
            processedFrame: imageData,
            histogramBins: scopes.histogramBins,
            waveformDensity: scopes.waveformDensity
        }, [imageData.data.buffer, scopes.histogramBins.buffer, scopes.waveformDensity.buffer]);
    };
    </script>

    <script type="module">
    const CineLogApp = {
        // ... (Main app logic will be here)
    };
    
    document.addEventListener('DOMContentLoaded', () => CineLogApp.init());
    </script>
    
    <script type="module">
    // This separation mimics having multiple JS files for clarity.
    
    const CineLogApp = {
        nodes: {}, state: {}, contexts: {}, constants: {},
        
        init() {
            this.setupConstants(); this.setupNodes(); this.setupState(); this.setupWorker();
            this.bootSequence(); this.bindEventListeners(); this.updateBatteryStatus();
            setInterval(this.updateBatteryStatus, 60000);
        },

        setupConstants() {
            this.constants = { FRAME_RATE: 30, SCOPE_UPDATE_INTERVAL: 4, // Process scopes every 4 frames
                LOG_PROFILES: {
                    'weblog': { name: 'WEB-LOG (Generic)', a: 0.25, b: 150 },
                    'clog':   { name: 'CINE-LOG (High DR)', a: 0.20, b: 400 },
                    'slog':   { name: 'SAT-LOG (Punchy)', a: 0.35, b: 80 },
                    'linear': { name: 'LINEAR (No LOG)', a: 1, b: 0 }
                }
            };
        },

        setupNodes() {
            this.nodes = {
                splash: { screen: document.getElementById('splash-screen'), logo: document.getElementById('splash-logo'), progressBarContainer: document.getElementById('progress-bar-container'), progressBar: document.getElementById('progress-bar'), status: document.getElementById('splash-status') },
                app: document.getElementById('app-container'), video: document.getElementById('video-element'), viewfinder: document.getElementById('video-viewfinder'),
                recIndicator: document.getElementById('rec-indicator'), recIndicatorText: document.querySelector('#rec-indicator span'), timecode: document.getElementById('timecode'), batteryStatus: document.getElementById('battery-status'),
                scopes: { histogram: document.getElementById('histogram-canvas'), waveform: document.getElementById('waveform-canvas') },
                controls: { recordButton: document.getElementById('record-button'), logProfile: document.getElementById('log-profile-select'), resolution: document.getElementById('resolution-select'), camera: document.getElementById('camera-select') },
                dialogs: { permission: document.getElementById('permission-dialog'), permissionButton: document.getElementById('grant-permission-button') },
                gallery: { modal: document.getElementById('gallery-modal'), grid: document.getElementById('gallery-grid'), emptyMessage: document.getElementById('gallery-empty-message'), closeButton: document.getElementById('close-gallery-button'), galleryButton: document.getElementById('gallery-button'), counter: document.getElementById('gallery-button-counter'), playerView: document.getElementById('gallery-player-view'), playerVideo: document.getElementById('gallery-player-video'), playerDownloadBtn: document.getElementById('player-download-button'), playerDeleteBtn: document.getElementById('player-delete-button'), playerCloseBtn: document.getElementById('player-close-button') }
            };
        },

        setupState() {
            this.state = {
                isRecording: false, isBooted: false, stream: null, mediaRecorder: null, recordedChunks: [],
                recordingStartTime: 0, animationFrameId: null, frameCounter: 0,
                currentLogProfile: 'weblog', currentCameraId: null, availableCameras: [], galleryClips: [],
                activePlayerClipId: null
            };
        },

        setupWorker() {
            const workerBlob = new Blob([document.getElementById('processing-worker').textContent], { type: 'application/javascript' });
            this.worker = new Worker(URL.createObjectURL(workerBlob));
            this.worker.postMessage({ type: 'init', logProfiles: this.constants.LOG_PROFILES });
            this.worker.onmessage = e => this.handleWorkerMessage(e.data);
        },

        bootSequence() {
            const statusUpdates = ["MOUNTING VFS...", "LOADING COLOR SCIENCE...", "SPOOLING WORKER THREAD...", "AWAITING PERMISSION..."];
            const tl = gsap.timeline({ onComplete: () => this.showDialog(this.nodes.dialogs.permission) });
            tl.to(this.nodes.splash.logo, { opacity: 1, y: 0, duration: 1.5, ease: 'power3.out' })
              .to([this.nodes.splash.progressBarContainer, this.nodes.splash.status], { opacity: 1, duration: 0.5 }, "-=1");
            statusUpdates.forEach((status, index) => {
                tl.to(this.nodes.splash.progressBar, { width: `${(index + 1) / statusUpdates.length * 100}%`, duration: 0.7, ease: 'none' })
                  .set(this.nodes.splash.status, { textContent: status });
            });
        },
        
        bindEventListeners() {
            this.nodes.dialogs.permissionButton.addEventListener('click', () => this.requestCameraPermission());
            this.nodes.controls.recordButton.addEventListener('click', () => this.toggleRecording());
            this.nodes.controls.logProfile.addEventListener('change', (e) => this.state.currentLogProfile = e.target.value);
            this.nodes.controls.resolution.addEventListener('change', () => this.restartStream());
            this.nodes.controls.camera.addEventListener('change', (e) => { this.state.currentCameraId = e.target.value; this.restartStream(); });
            this.nodes.gallery.galleryButton.addEventListener('click', () => this.showGallery());
            this.nodes.gallery.closeButton.addEventListener('click', () => this.hideGallery());
            this.nodes.gallery.grid.addEventListener('click', e => this.handleGalleryItemClick(e));
            this.nodes.gallery.playerCloseBtn.addEventListener('click', () => this.hidePlayer());
            this.nodes.gallery.playerDownloadBtn.addEventListener('click', () => this.downloadActiveClip());
            this.nodes.gallery.playerDeleteBtn.addEventListener('click', () => this.deleteActiveClip());
        },

        async enumerateCameras() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            this.state.availableCameras = devices.filter(d => d.kind === 'videoinput');
            this.nodes.controls.camera.innerHTML = this.state.availableCameras
                .map(d => `<option value="${d.deviceId}">${d.label || `Camera ${this.nodes.controls.camera.options.length + 1}`}</option>`)
                .join('');
            if(!this.state.currentCameraId && this.state.availableCameras.length > 0) {
                this.state.currentCameraId = this.state.availableCameras[0].deviceId;
            }
        },

        async getCameraStream() {
            const resolution = this.getResolution();
            const constraints = { audio: true, video: { width: { ideal: resolution.width }, height: { ideal: resolution.height }, frameRate: { ideal: this.constants.FRAME_RATE }, deviceId: this.state.currentCameraId ? { exact: this.state.currentCameraId } : undefined }};
            return navigator.mediaDevices.getUserMedia(constraints);
        },
        
        async requestCameraPermission() {
            this.hideDialog(this.nodes.dialogs.permission);
            gsap.fromTo(this.nodes.splash.status, { opacity: 0 }, { opacity: 1, duration: 0.5, textContent: 'ENUMERATING DEVICES...' });
            try {
                // Dummy call to get permission and enumerate devices with labels
                const tempStream = await navigator.mediaDevices.getUserMedia({video: true});
                tempStream.getTracks().forEach(track => track.stop());

                await this.enumerateCameras();
                this.state.stream = await this.getCameraStream();
                this.nodes.video.srcObject = this.state.stream;
                this.nodes.video.onloadedmetadata = () => this.startSystem();
            } catch (err) {
                console.error("Monumental Error: Camera access denied or unavailable.", err);
                this.nodes.splash.status.textContent = 'CAMERA ACCESS DENIED. REFRESH & ALLOW.';
                gsap.to(this.nodes.splash.status, { color: 'var(--color-accent-danger)' });
            }
        },
        
        getResolution() {
            const res = this.nodes.controls.resolution.value;
            if (res === '1080p') return { width: 1920, height: 1080 };
            if (res === '480p') return { width: 640, height: 480 };
            return { width: 1280, height: 720 };
        },

        async restartStream() {
            if (this.state.isRecording) return;
            this.stopProcessingLoop();
            if (this.state.stream) this.state.stream.getTracks().forEach(track => track.stop());
            try {
                this.state.stream = await this.getCameraStream();
                this.nodes.video.srcObject = this.state.stream;
                this.nodes.video.onloadedmetadata = () => { this.reinitializeViewfinder(); this.startProcessingLoop(); };
            } catch(err) {
                console.error("Failed to restart stream:", err);
                alert("Failed to switch camera/resolution. The requested settings may not be supported by this device.");
            }
        },
        
        startSystem() {
            gsap.to(this.nodes.splash.screen, { opacity: 0, duration: this.constants.transition_speed_slow, onComplete: () => this.nodes.splash.screen.style.display = 'none' });
            gsap.fromTo(this.nodes.app, { visibility: 'hidden', opacity: 0 }, { visibility: 'visible', opacity: 1, duration: 1.5, ease: 'power2.out' });
            this.reinitializeViewfinder();
            this.startProcessingLoop();
            this.state.isBooted = true;
        },

        reinitializeViewfinder() {
            this.nodes.viewfinder.width = this.nodes.video.videoWidth; this.nodes.viewfinder.height = this.nodes.video.videoHeight;
            this.contexts.viewfinder = this.nodes.viewfinder.getContext('2d', { willReadFrequently: true });
            ['histogram', 'waveform'].forEach(scope => {
                const canvas = this.nodes.scopes[scope]; canvas.width = 128; canvas.height = 96; this.contexts[scope] = canvas.getContext('2d');
            });
        },
        
        startProcessingLoop() {
            if (this.state.animationFrameId) cancelAnimationFrame(this.state.animationFrameId);
            const loop = () => {
                if (!this.state.stream || this.nodes.video.paused || this.nodes.video.ended) return;
                this.contexts.viewfinder.drawImage(this.nodes.video, 0, 0, this.nodes.viewfinder.width, this.nodes.viewfinder.height);
                const imageData = this.contexts.viewfinder.getImageData(0, 0, this.nodes.viewfinder.width, this.nodes.viewfinder.height);
                this.worker.postMessage({ imageData, logProfileId: this.state.currentLogProfile, width: this.nodes.viewfinder.width, height: this.nodes.viewfinder.height }, [imageData.data.buffer]);
                if (this.state.isRecording) this.updateTimecode();
                this.state.frameCounter++;
                this.state.animationFrameId = requestAnimationFrame(loop);
            };
            this.state.animationFrameId = requestAnimationFrame(loop);
        },
        
        stopProcessingLoop() {
            if(this.state.animationFrameId) { cancelAnimationFrame(this.state.animationFrameId); this.state.animationFrameId = null; }
        },

        handleWorkerMessage({ processedFrame, histogramBins, waveformDensity }) {
            this.contexts.viewfinder.putImageData(processedFrame, 0, 0);
            if(this.state.frameCounter % this.constants.SCOPE_UPDATE_INTERVAL === 0) {
                this.drawHistogram(histogramBins);
                this.drawWaveform(waveformDensity);
            }
        },

        drawHistogram(bins) {
            const ctx = this.contexts.histogram; let maxBin = 0;
            for (let i = 0; i < 256; i++) { if (bins[i] > maxBin) maxBin = bins[i]; }
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ctx.fillStyle = `rgba(0, 255, 255, 0.7)`;
            if(maxBin === 0) return;
            for (let i = 0; i < 256; i++) {
                const h = (bins[i] / maxBin) * ctx.canvas.height, x = (i / 256) * ctx.canvas.width, w = ctx.canvas.width / 256;
                ctx.fillRect(x, ctx.canvas.height - h, w, h);
            }
        },

        drawWaveform(densityData) {
            const ctx = this.contexts.waveform; const w = ctx.canvas.width, h = ctx.canvas.height;
            ctx.clearRect(0, 0, w, h);
            const imgData = ctx.createImageData(w, h);
            for(let i=0; i < densityData.length; i++) {
                const d = densityData[i]; if(d === 0) continue;
                const bi = i * 4, val = Math.min(255, d * 5);
                imgData.data[bi] = 0; imgData.data[bi + 1] = val; imgData.data[bi + 2] = val; imgData.data[bi + 3] = 255;
            }
            ctx.putImageData(imgData, 0, 0);
        },

        toggleRecording() {
            this.state.isRecording = !this.state.isRecording;
            if (this.state.isRecording) {
                this.state.recordedChunks = [];
                const canvasStream = this.nodes.viewfinder.captureStream(this.constants.FRAME_RATE);
                const audioTracks = this.state.stream.getAudioTracks();
                if (audioTracks.length > 0) canvasStream.addTrack(audioTracks[0].clone()); // Use clone to avoid stopping original track
                let options = { mimeType: 'video/webm; codecs=vp9,opus' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) options = { mimeType: 'video/webm; codecs=vp8,opus' };
                this.state.mediaRecorder = new MediaRecorder(canvasStream, options);
                this.state.mediaRecorder.ondataavailable = e => { if (e.data.size > 0) this.state.recordedChunks.push(e.data); };
                this.state.mediaRecorder.onstop = () => this.addClipToGallery();
                this.state.mediaRecorder.start(1000); // Timeslice to manage memory
                this.state.recordingStartTime = Date.now();
                this.nodes.recIndicator.classList.add('recording');
                this.nodes.recIndicatorText.textContent = 'REC';
                this.nodes.controls.recordButton.classList.add('recording');
            } else {
                if (this.state.mediaRecorder && this.state.mediaRecorder.state === 'recording') this.state.mediaRecorder.stop();
                this.nodes.recIndicator.classList.remove('recording');
                this.nodes.recIndicatorText.textContent = 'STANDBY';
                this.nodes.controls.recordButton.classList.remove('recording');
                this.nodes.timecode.textContent = '00:00:00:00';
            }
        },

        async addClipToGallery() {
            const videoBlob = new Blob(this.state.recordedChunks, { type: 'video/webm' });
            const videoUrl = URL.createObjectURL(videoBlob);
            const clipId = Date.now();
            const timestamp = new Date(clipId).toISOString().replace(/[:.]/g, '-');
            const metadata = {
                clip_id: clipId, timestamp_utc: new Date(clipId).toISOString(),
                log_profile: this.constants.LOG_PROFILES[this.state.currentLogProfile],
                resolution: { width: this.nodes.viewfinder.width, height: this.nodes.viewfinder.height },
                engine: "CINE-LOG.WEB v2.0",
                notes: "Crucial for post-production. Use 'log_profile' parameters to invert the LOG curve to linear space before grading."
            };
            const thumbnailUrl = await this.createThumbnail();
            
            this.state.galleryClips.push({ id: clipId, videoBlob, videoUrl, metadata, thumbnailUrl });
            this.renderGallery();
            this.updateGalleryCounter();
        },

        createThumbnail() {
            return new Promise(resolve => {
                const thumbCanvas = document.createElement('canvas');
                const thumbCtx = thumbCanvas.getContext('2d');
                const w = 320, h = 180;
                thumbCanvas.width = w; thumbCanvas.height = h;
                thumbCtx.drawImage(this.nodes.viewfinder, 0, 0, w, h);
                resolve(thumbCanvas.toDataURL('image/jpeg', 0.8));
            });
        },
        
        renderGallery() {
            if (this.state.galleryClips.length === 0) {
                this.nodes.gallery.grid.innerHTML = '';
                this.nodes.gallery.emptyMessage.style.display = 'flex';
                return;
            }
            this.nodes.gallery.emptyMessage.style.display = 'none';
            this.nodes.gallery.grid.innerHTML = this.state.galleryClips
                .map(clip => `
                    <div class="gallery-item" data-clip-id="${clip.id}">
                        <img src="${clip.thumbnailUrl}" alt="Clip thumbnail">
                        <div class="gallery-item-info">
                            <span>${new Date(clip.id).toLocaleTimeString()}</span>
                            <span>${clip.metadata.log_profile.name}</span>
                        </div>
                    </div>
                `).join('');
        },

        updateGalleryCounter() {
            const count = this.state.galleryClips.length;
            this.nodes.gallery.counter.textContent = count;
            this.nodes.gallery.counter.classList.toggle('visible', count > 0);
        },

        handleGalleryItemClick(event) {
            const item = event.target.closest('.gallery-item');
            if (item) {
                const clipId = Number(item.dataset.clipId);
                this.state.activePlayerClipId = clipId;
                const clip = this.state.galleryClips.find(c => c.id === clipId);
                if (clip) this.showPlayer(clip.videoUrl);
            }
        },

        showPlayer(videoUrl) {
            this.nodes.gallery.playerVideo.src = videoUrl;
            gsap.fromTo(this.nodes.gallery.playerView, { opacity: 0, visibility: 'hidden' }, { opacity: 1, visibility: 'visible', duration: 0.3 });
        },

        hidePlayer() {
            gsap.to(this.nodes.gallery.playerView, { opacity: 0, duration: 0.3, onComplete: () => {
                this.nodes.gallery.playerView.style.visibility = 'hidden';
                this.nodes.gallery.playerVideo.pause();
                this.nodes.gallery.playerVideo.src = '';
                this.state.activePlayerClipId = null;
            }});
        },

        downloadActiveClip() {
            const clip = this.state.galleryClips.find(c => c.id === this.state.activePlayerClipId);
            if (!clip) return;
            const timestamp = new Date(clip.id).toISOString().replace(/[:.]/g, '-');

            // Download video
            const aVideo = document.createElement('a');
            aVideo.href = clip.videoUrl;
            aVideo.download = `CINE-LOG_${timestamp}.webm`;
            document.body.appendChild(aVideo);
            aVideo.click();
            document.body.removeChild(aVideo);

            // Download metadata
            const metaBlob = new Blob([JSON.stringify(clip.metadata, null, 2)], { type: 'application/json' });
            const metaUrl = URL.createObjectURL(metaBlob);
            const aMeta = document.createElement('a');
            aMeta.href = metaUrl;
            aMeta.download = `CINE-LOG_${timestamp}_meta.json`;
            document.body.appendChild(aMeta);
            aMeta.click();
            document.body.removeChild(aMeta);
            URL.revokeObjectURL(metaUrl);
        },
        
        deleteActiveClip() {
            const clipIndex = this.state.galleryClips.findIndex(c => c.id === this.state.activePlayerClipId);
            if (clipIndex > -1) {
                const [deletedClip] = this.state.galleryClips.splice(clipIndex, 1);
                URL.revokeObjectURL(deletedClip.videoUrl); // CRITICAL: Prevent memory leaks
                URL.revokeObjectURL(deletedClip.thumbnailUrl);
                this.hidePlayer();
                this.renderGallery();
                this.updateGalleryCounter();
            }
        },

        showDialog(dialogNode) {
            gsap.set(dialogNode, { display: 'flex' });
            gsap.to(dialogNode, { duration: 0.5, opacity: 1, ease: 'power2.out', onComplete: () => {
                dialogNode.classList.add('visible');
            }});
        },

        hideDialog(dialogNode) {
            gsap.to(dialogNode, { duration: 0.3, opacity: 0, ease: 'power2.in', onComplete: () => {
                dialogNode.style.display = 'none';
                dialogNode.classList.remove('visible');
            }});
        },

        showGallery() { this.showDialog(this.nodes.gallery.modal); },
        hideGallery() { this.hideDialog(this.nodes.gallery.modal); if (this.state.activePlayerClipId) this.hidePlayer(); },

        updateTimecode() {
            const e = Date.now() - this.state.recordingStartTime, s = Math.floor(e / 1000);
            const h=String(Math.floor(s/3600)).padStart(2,'0'), m=String(Math.floor((s%3600)/60)).padStart(2,'0'), sec=String(s%60).padStart(2,'0'), f=String(Math.floor((e%1000)/(1000/this.constants.FRAME_RATE))).padStart(2,'0');
            this.nodes.timecode.textContent = `${h}:${m}:${sec}:${f}`;
        },

        async updateBatteryStatus() {
            try {
                if ('getBattery' in navigator) {
                    const battery = await navigator.getBattery(); const level = Math.floor(battery.level * 100);
                    this.nodes.batteryStatus.textContent = `BATT ${level}%`; this.nodes.batteryStatus.style.color = level < 20 ? 'var(--color-accent-danger)' : 'var(--color-text-primary)';
                }
            } catch (err) { this.nodes.batteryStatus.textContent = `BATT N/A`; }
        }
    };

    window.CineLogApp = CineLogApp; // Expose for easier debugging in console
    document.addEventListener('DOMContentLoaded', () => CineLogApp.init());
    </script>
</body>
</html>
