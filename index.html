<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CINE-LOG.WEB v2.1 | Real-time LOG Video Pipeline</title>
    <meta name="description" content="A monumental in-browser application for real-time LOG video recording and processing, architected with a dedicated worker core, an integrated media gallery, and a fortified, error-resilient recording pipeline.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;700&family=Teko:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <style>
        /* [1] === CORE RESET & THEME ARCHITECTURE === */
        :root {
            --color-background: #000000;
            --color-primary-dark: #0a0a0a;
            --color-primary-medium: #111111;
            --color-primary-light: #1a1a1a;
            --color-accent: #00ffff;
            --color-accent-secondary: #ff00ff;
            --color-accent-danger: #ff4141;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #8a8a8a;
            --font-primary: 'Teko', sans-serif;
            --font-secondary: 'Roboto Mono', monospace;
            --transition-speed-fast: 0.3s;
            --transition-speed-medium: 0.5s;
            --transition-speed-slow: 0.8s;
            --ease-out: cubic-bezier(0.165, 0.84, 0.44, 1);
            --ease-in-out: cubic-bezier(0.77, 0, 0.175, 1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--color-background);
            color: var(--color-text-primary);
            font-family: var(--font-secondary);
            font-size: 10px;
            -webkit-tap-highlight-color: transparent;
        }

        /* [2] === SPLASH SCREEN / BOOT SEQUENCE === */
        #splash-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--color-background); z-index: 10000; display: flex; justify-content: center; align-items: center; flex-direction: column; color: var(--color-accent);
        }
        #splash-logo { font-family: var(--font-primary); font-size: 8rem; font-weight: 600; letter-spacing: 4px; opacity: 0; transform: translateY(20px); }
        #splash-logo span { color: var(--color-text-primary); font-weight: 300; }
        #progress-bar-container { width: 80%; max-width: 400px; height: 2px; background: rgba(0, 255, 255, 0.2); margin-top: 2rem; opacity: 0; }
        #progress-bar { width: 0%; height: 100%; background: var(--color-accent); }
        #splash-status { margin-top: 1.5rem; font-size: 1.4rem; letter-spacing: 1px; opacity: 0; text-transform: uppercase; }

        /* [3] === MAIN APPLICATION INTERFACE === */
        #app-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; visibility: hidden; opacity: 0; background: var(--color-primary-dark); }
        #video-viewfinder { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        #video-element { display: none; }
        
        /* [4] === HEADS-UP DISPLAY (HUD) & OVERLAYS === */
        .hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: grid; grid-template-rows: 60px 1fr 120px; grid-template-columns: 150px 1fr 150px; }
        .hud-element { padding: 1rem; color: var(--color-text-primary); font-size: 1.2rem; text-shadow: 0 0 5px rgba(0,0,0,0.7); }
        #status-bar { grid-column: 1 / 4; grid-row: 1 / 2; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent); padding: 1rem 2rem; }
        #rec-indicator { display: flex; align-items: center; font-weight: 700; font-size: 1.8rem; letter-spacing: 2px; color: var(--color-text-secondary); transition: color var(--transition-speed-fast); }
        #rec-indicator.recording { color: var(--color-accent-danger); }
        #rec-indicator .dot { width: 10px; height: 10px; background-color: currentColor; border-radius: 50%; margin-right: 8px; animation: pulse-animation 1.5s infinite; opacity: 0; transition: opacity var(--transition-speed-fast); }
        #rec-indicator.recording .dot { opacity: 1; }
        @keyframes pulse-animation { 0% { transform: scale(1); } 50% { transform: scale(0.8); } 100% { transform: scale(1); } }
        #timecode { font-size: 1.8rem; font-weight: 700; }
        #battery-status { font-size: 1.4rem; }
        #scopes-panel { grid-column: 1 / 2; grid-row: 2 / 3; display: flex; flex-direction: column; gap: 1rem; padding-left: 1rem; }
        .scope-container { background: rgba(10, 10, 10, 0.7); border: 1px solid var(--color-primary-light); border-radius: 4px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); padding: 0.5rem; }
        .scope-container h3 { font-family: var(--font-primary); font-size: 1.6rem; font-weight: 400; color: var(--color-accent); margin-bottom: 0.5rem; text-align: center; }
        .scope-canvas { width: 100%; aspect-ratio: 4/3; }
        #control-panel { grid-column: 3 / 4; grid-row: 2 / 3; display: flex; flex-direction: column; gap: 1.5rem; padding-right: 1rem; pointer-events: all; }
        .control-group { background: rgba(10, 10, 10, 0.7); border: 1px solid var(--color-primary-light); border-radius: 4px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); padding: 1rem; }
        .control-group label { display: block; font-family: var(--font-primary); font-size: 1.6rem; color: var(--color-accent); margin-bottom: 0.8rem; }
        .control-group select, .control-group input { width: 100%; background: var(--color-primary-medium); border: 1px solid var(--color-primary-light); color: var(--color-text-primary); font-family: var(--font-secondary); padding: 0.5rem; border-radius: 2px; font-size: 1.2rem; }
        #action-bar { grid-column: 1 / 4; grid-row: 3 / 4; display: flex; justify-content: center; align-items: center; gap: 3rem; background: linear-gradient(to top, rgba(0,0,0,0.6), transparent); pointer-events: all; }
        #record-button { width: 70px; height: 70px; background: var(--color-primary-dark); border: 4px solid var(--color-text-secondary); border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all var(--transition-speed-fast) var(--ease-out); }
        #record-button .inner-circle { width: 80%; height: 80%; background: var(--color-accent-danger); border-radius: 50%; transition: all var(--transition-speed-fast) var(--ease-out); }
        #record-button.recording { border-color: var(--color-accent-danger); }
        #record-button.recording .inner-circle { border-radius: 15%; transform: scale(0.8); }
        .action-button { width: 50px; height: 50px; background: var(--color-primary-medium); border: 2px solid var(--color-text-secondary); border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all var(--transition-speed-fast) var(--ease-out); position: relative; }
        .action-button:hover { border-color: var(--color-accent); }
        .action-button svg { width: 24px; height: 24px; fill: var(--color-text-primary); transition: fill var(--transition-speed-fast) var(--ease-out); }
        .action-button:hover svg { fill: var(--color-accent); }
        .notification-dot { position: absolute; top: 2px; right: 2px; width: 10px; height: 10px; background-color: var(--color-accent); border-radius: 50%; border: 2px solid var(--color-primary-medium); transform: scale(0); opacity: 0; transition: transform 0.3s var(--ease-out), opacity 0.3s; }
        .notification-dot.visible { transform: scale(1); opacity: 1; }
        
        /* [5] === DIALOGS & OVERLAYS === */
        .dialog-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10001; display: none; opacity: 0; justify-content: center; align-items: center; padding: 2rem; }
        .dialog-content { background: var(--color-primary-dark); border: 1px solid var(--color-accent); padding: 3rem; max-width: 500px; text-align: center; }
        .dialog-content h2 { font-family: var(--font-primary); font-size: 3rem; color: var(--color-accent); margin-bottom: 1.5rem; }
        .dialog-content p { font-size: 1.4rem; line-height: 1.6; margin-bottom: 2rem; color: var(--color-text-secondary); }
        .dialog-button { background: var(--color-accent); color: var(--color-background); border: none; padding: 1rem 3rem; font-family: var(--font-secondary); font-size: 1.6rem; font-weight: 700; cursor: pointer; transition: all var(--transition-speed-fast); }
        .dialog-button:hover { opacity: 0.8; }
        
        /* [6] === GALLERY ECOSYSTEM === */
        #gallery-view { z-index: 9000; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); }
        .gallery-container { width: 100%; height: 100%; display: flex; flex-direction: column; padding: 2rem; }
        .gallery-header { display: flex; justify-content: space-between; align-items: center; padding: 1rem; border-bottom: 1px solid var(--color-primary-light); }
        .gallery-header h2 { font-family: var(--font-primary); font-size: 4rem; color: var(--color-accent); }
        .gallery-close-button { font-size: 3rem; color: var(--color-text-secondary); cursor: pointer; transition: color var(--transition-speed-fast); }
        .gallery-close-button:hover { color: var(--color-accent); }
        #gallery-grid { flex-grow: 1; overflow-y: auto; padding: 2rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 2rem; }
        .gallery-item { position: relative; background: var(--color-primary-medium); border-radius: 4px; overflow: hidden; border: 1px solid var(--color-primary-light); cursor: pointer; aspect-ratio: 16/9; }
        .gallery-item-thumb { width: 100%; height: 100%; object-fit: cover; transition: transform var(--transition-speed-fast) var(--ease-out); }
        .gallery-item:hover .gallery-item-thumb { transform: scale(1.05); }
        .gallery-item-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to top, rgba(0,0,0,0.8), transparent 50%); display: flex; flex-direction: column; justify-content: space-between; padding: 1rem; }
        .gallery-item-info { font-size: 1.1rem; }
        .gallery-item-actions { display: flex; justify-content: end; gap: 0.8rem; }
        .gallery-item-actions button { background: rgba(0,0,0,0.5); border: 1px solid var(--color-text-secondary); color: var(--color-text-primary); border-radius: 50%; width: 32px; height: 32px; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: all var(--transition-speed-fast); }
        .gallery-item-actions button:hover { background: var(--color-accent); border-color: var(--color-accent); }
        .gallery-item-actions button svg { width: 16px; height: 16px; fill: currentColor; }
        .play-icon-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.8); opacity: 0; transition: all var(--transition-speed-fast) var(--ease-out); pointer-events: none; }
        .gallery-item:hover .play-icon-overlay { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        .play-icon-overlay svg { width: 50px; height: 50px; fill: rgba(255,255,255,0.9); filter: drop-shadow(0 0 5px black); }

        #gallery-player { z-index: 9001; }
        .player-container { position: relative; width: 90vw; height: auto; max-width: 1600px; aspect-ratio: 16/9; background: #000; }
        .player-container video { width: 100%; height: 100%; }
        .player-close-button { position: absolute; top: -30px; right: -10px; font-size: 3rem; color: var(--color-text-primary); cursor: pointer; background: rgba(0,0,0,0.5); border-radius: 50%; width: 40px; height: 40px; display:flex; justify-content:center; align-items:center; line-height: 1; }

    </style>
</head>
<body>
    <!-- The DOM structure remains identical to the previous version -->
    <!-- [UI] SPLASH SCREEN -->
    <div id="splash-screen">
        <div id="splash-logo">CINE-LOG<span>.WEB v2.1</span></div>
        <div id="progress-bar-container"><div id="progress-bar"></div></div>
        <div id="splash-status">INITIALIZING KERNEL</div>
    </div>

    <!-- [UI] MAIN APPLICATION -->
    <div id="app-container">
        <video id="video-element" playsinline autoplay muted></video>
        <canvas id="video-viewfinder"></canvas>
        <div class="hud">
            <!-- Top Bar -->
            <div id="status-bar" class="hud-element">
                <div id="rec-indicator"><div class="dot"></div><span>STANDBY</span></div>
                <div id="timecode">00:00:00:00</div>
                <div id="battery-status">BATT --%</div>
            </div>
            <!-- Left Scopes -->
            <div id="scopes-panel" class="hud-element">
                <div class="scope-container">
                    <h3>LUMA HISTOGRAM</h3>
                    <canvas id="histogram-canvas" class="scope-canvas" width="128" height="96"></canvas>
                </div>
                <div class="scope-container">
                    <h3>LUMA WAVEFORM</h3>
                    <canvas id="waveform-canvas" class="scope-canvas" width="128" height="96"></canvas>
                </div>
            </div>
            <!-- Right Controls -->
            <div id="control-panel" class="hud-element">
                 <div class="control-group">
                    <label for="log-profile-select">LOG PROFILE</label>
                    <select id="log-profile-select">
                        <option value="weblog">WEB-LOG (Generic)</option>
                        <option value="clog">CINE-LOG (High DR)</option>
                        <option value="slog">SAT-LOG (Punchy)</option>
                        <option value="linear">LINEAR (No LOG)</option>
                    </select>
                </div>
                 <div class="control-group">
                    <label for="resolution-select">RESOLUTION</label>
                    <select id="resolution-select">
                        <option value="1080p">1920x1080</option>
                        <option value="720p" selected>1280x720</option>
                        <option value="480p">640x480</option>
                    </select>
                </div>
            </div>
            <!-- Bottom Actions -->
            <div id="action-bar" class="hud-element">
                <div id="switch-camera-button" class="action-button">
                    <svg viewBox="0 0 24 24"><path d="M9 3L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2h-3.17L15 3H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.65 0-3 1.35-3 3s1.35 3 3 3 3-1.35 3-3-1.35-3-3-3z"/></svg>
                </div>
                <div id="record-button"><div class="inner-circle"></div></div>
                <div id="gallery-button" class="action-button">
                    <div id="gallery-notification" class="notification-dot"></div>
                    <svg viewBox="0 0 24 24"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"/></svg>
                </div>
            </div>
        </div>
    </div>
    
    <!-- [UI] DIALOGS -->
    <div id="permission-dialog" class="dialog-overlay">
        <div class="dialog-content">
            <h2>ACCESS REQUIRED</h2>
            <p>CINE-LOG.WEB requires access to your device's camera to initiate the real-time processing pipeline.</p>
            <button id="grant-permission-button" class="dialog-button">GRANT ACCESS</button>
        </div>
    </div>

    <!-- [UI] GALLERY -->
    <div id="gallery-view" class="dialog-overlay">
        <div class="gallery-container">
            <div class="gallery-header">
                <h2>CLIP GALLERY</h2>
                <div id="gallery-close-button" class="gallery-close-button">&times;</div>
            </div>
            <div id="gallery-grid">
                <!-- Gallery items will be injected here -->
            </div>
        </div>
    </div>

    <!-- [UI] GALLERY PLAYER -->
    <div id="gallery-player" class="dialog-overlay">
         <div class="player-container">
            <video id="player-video-element" controls></video>
            <div id="player-close-button" class="gallery-close-button">&times;</div>
        </div>
    </div>

    <!-- [WORKER] SCOPE ANALYSIS WORKER (Unchanged) -->
    <script type="javascript/worker" id="scope-worker">
        let histogramCanvas, histogramCtx, waveformCanvas, waveformCtx;
        
        self.onmessage = function(e) {
            const { type, payload } = e.data;
            switch(type) {
                case 'init':
                    histogramCanvas = payload.histogramCanvas;
                    histogramCtx = histogramCanvas.getContext('2d');
                    waveformCanvas = payload.waveformCanvas;
                    waveformCtx = waveformCanvas.getContext('2d');
                    break;
                case 'processFrame':
                    const lumaValues = calculateLuma(payload.imageData);
                    drawHistogram(lumaValues);
                    drawWaveform(lumaValues, payload.sourceWidth, payload.sourceHeight);
                    
                    self.postMessage({
                        type: 'renderReady',
                        payload: {
                            histogramBitmap: histogramCanvas.transferToImageBitmap(),
                            waveformBitmap: waveformCanvas.transferToImageBitmap()
                        }
                    });
                    break;
            }
        };

        function calculateLuma(data) {
            const lumaValues = new Uint8ClampedArray(data.length / 4);
            for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                lumaValues[j] = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
            }
            return lumaValues;
        }

        function drawHistogram(lumaValues) {
            const bins = new Uint32Array(256).fill(0);
            for (let i = 0; i < lumaValues.length; i++) { bins[lumaValues[i]]++; }
            
            const sortedBins = [...bins].sort((a,b) => a-b);
            let maxBin = sortedBins[Math.floor(255 * 0.99)] || 1;

            histogramCtx.clearRect(0, 0, histogramCanvas.width, histogramCanvas.height);
            histogramCtx.fillStyle = 'rgba(0, 255, 255, 0.7)';
            
            const w = histogramCanvas.width / 256;
            for (let i = 0; i < 256; i++) {
                if (bins[i] > 0) {
                   const h = (bins[i] / maxBin) * histogramCanvas.height;
                   histogramCtx.fillRect(i * w, histogramCanvas.height - h, w, h);
                }
            }
        }
        
        function drawWaveform(lumaValues, sourceWidth, sourceHeight) {
            const w = waveformCanvas.width;
            const h = waveformCanvas.height;
            const densityData = new Uint8ClampedArray(w * h).fill(0);
            
            const stepY = Math.max(1, Math.floor(sourceHeight / h));
            const stepX = Math.max(1, Math.floor(sourceWidth / w));

            for (let y = 0; y < sourceHeight; y+=stepY) {
                for (let x = 0; x < sourceWidth; x+=stepX) {
                    const luma = lumaValues[y * sourceWidth + x];
                    const wx = Math.floor((x / sourceWidth) * w);
                    const wy = Math.floor(h - 1 - (luma / 255) * (h - 1));
                    const idx = wy * w + wx;
                    if (densityData[idx] < 255) densityData[idx] = Math.min(255, densityData[idx] + 8);
                }
            }
            
            waveformCtx.clearRect(0, 0, w, h);
            const imgData = waveformCtx.createImageData(w, h);
            for (let i = 0; i < densityData.length; i++) {
                const d = densityData[i];
                if (d > 0) {
                    const bi = i * 4;
                    imgData.data[bi] = 0;
                    imgData.data[bi + 1] = Math.min(255, d * 8);
                    imgData.data[bi + 2] = Math.min(255, d * 8);
                    imgData.data[bi + 3] = 255;
                }
            }
            waveformCtx.putImageData(imgData, 0, 0);
        }
    </script>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {

        const CineLogApp = {
            // nodes, logProfiles, contexts... (all unchanged)
            nodes: {
                splash: { screen: document.getElementById('splash-screen'), logo: document.getElementById('splash-logo'), progressBarContainer: document.getElementById('progress-bar-container'), progressBar: document.getElementById('progress-bar'), status: document.getElementById('splash-status') },
                app: document.getElementById('app-container'),
                video: document.getElementById('video-element'),
                viewfinder: document.getElementById('video-viewfinder'),
                recIndicator: document.getElementById('rec-indicator'),
                recIndicatorText: document.querySelector('#rec-indicator span'),
                timecode: document.getElementById('timecode'),
                batteryStatus: document.getElementById('battery-status'),
                scopes: { 
                    histogram: document.getElementById('histogram-canvas'), 
                    waveform: document.getElementById('waveform-canvas'), 
                },
                controls: { 
                    recordButton: document.getElementById('record-button'), 
                    switchCameraButton: document.getElementById('switch-camera-button'),
                    galleryButton: document.getElementById('gallery-button'),
                    logProfile: document.getElementById('log-profile-select'), 
                    resolution: document.getElementById('resolution-select') 
                },
                dialogs: { 
                    permission: document.getElementById('permission-dialog'), 
                    permissionButton: document.getElementById('grant-permission-button') 
                },
                gallery: {
                    view: document.getElementById('gallery-view'),
                    grid: document.getElementById('gallery-grid'),
                    closeButton: document.getElementById('gallery-close-button'),
                    notification: document.getElementById('gallery-notification'),
                    playerView: document.getElementById('gallery-player'),
                    playerVideo: document.getElementById('player-video-element'),
                    playerCloseButton: document.getElementById('player-close-button'),
                }
            },
            state: {
                isRecording: false, stream: null, mediaRecorder: null, recordedChunks: [], recordingStartTime: 0, animationFrameId: null, currentLogProfile: 'weblog', currentFacingMode: 'environment',
                scopeWorker: null, isProcessingFrame: false, galleryClips: [], hasNewClips: false,
            },
            logProfiles: {
                'weblog': { name: 'WEB-LOG (Generic)', a: 0.25, b: 150 }, 'clog':   { name: 'CINE-LOG (High DR)', a: 0.20, b: 400 }, 'slog':   { name: 'SAT-LOG (Punchy)', a: 0.35, b: 80 }, 'linear': { name: 'LINEAR (No LOG)', a: 1, b: 0 }
            },
            contexts: { viewfinder: null, histogram: null, waveform: null },

            init() {
                this.bootSequence();
                this.setupEventListeners();
                this.updateBatteryStatus();
                setInterval(() => this.updateBatteryStatus(), 60000);
            },
            // The vast majority of the logic remains unchanged. Only the recording functions are modified.
            // bootSequence, setupEventListeners, requestCameraPermission, getCameraStream, switchCamera, restartStream, startSystem, setupWorker, startProcessingLoop, stopProcessingLoop, applyLogTransform... are all IDENTICAL to the previous version.
            // For brevity, I will omit the identical functions and focus on the re-architected recording logic.
            
            // ... [Identical functions from previous version go here] ...
            bootSequence() {
                const statusUpdates = ["MOUNTING VFS...", "LOADING COLOR SCIENCE...", "INITIALIZING WORKER CORE...", "CALIBRATING SENSORS...", "AWAITING PERMISSION..."];
                const tl = gsap.timeline({ onComplete: () => this.UIManager.showDialog(this.nodes.dialogs.permission) });
                tl.to(this.nodes.splash.logo, { opacity: 1, y: 0, duration: 1.5, ease: 'power3.out' })
                  .to([this.nodes.splash.progressBarContainer, this.nodes.splash.status], { opacity: 1, duration: 0.5 }, "-=1");
                statusUpdates.forEach((status, index) => {
                    tl.to(this.nodes.splash.progressBar, { width: `${(index + 1) / statusUpdates.length * 100}%`, duration: 0.7, ease: 'none' })
                      .set(this.nodes.splash.status, { textContent: status });
                });
            },
            
            setupEventListeners() {
                this.nodes.dialogs.permissionButton.addEventListener('click', () => this.requestCameraPermission());
                this.nodes.controls.recordButton.addEventListener('click', () => this.toggleRecording());
                this.nodes.controls.switchCameraButton.addEventListener('click', () => this.switchCamera());
                this.nodes.controls.logProfile.addEventListener('change', (e) => this.state.currentLogProfile = e.target.value);
                this.nodes.controls.resolution.addEventListener('change', () => this.restartStream());
                this.nodes.controls.galleryButton.addEventListener('click', () => this.UIManager.showGallery(this.state.galleryClips, this.nodes.gallery, this));
                this.nodes.gallery.closeButton.addEventListener('click', () => this.UIManager.hideGallery());
                this.nodes.gallery.playerCloseButton.addEventListener('click', () => this.UIManager.hidePlayer());
                this.nodes.gallery.grid.addEventListener('click', (e) => {
                    const item = e.target.closest('.gallery-item');
                    if (!item) return;
                    const clipId = item.dataset.clipId;
                    const actionButton = e.target.closest('[data-action]');
                    if (actionButton) {
                        const action = actionButton.dataset.action;
                        e.stopPropagation();
                        if (action === 'download') this.downloadClip(clipId);
                        if (action === 'delete') this.deleteClip(clipId);
                    } else { this.playClip(clipId); }
                });
            },

            async requestCameraPermission() {
                this.UIManager.hideDialog(this.nodes.dialogs.permission);
                gsap.fromTo(this.nodes.splash.status, { opacity: 0 }, { opacity: 1, duration: 0.5, textContent: 'ACCESSING CAMERA STREAM...' });
                try {
                    this.state.stream = await this.getCameraStream();
                    this.nodes.video.srcObject = this.state.stream;
                    this.nodes.video.onloadedmetadata = () => this.startSystem();
                } catch (err) {
                    console.error("Monumental Error: Camera access denied or unavailable.", err);
                    gsap.to(this.nodes.splash.status, { textContent: 'CAMERA ACCESS DENIED. REFRESH & ALLOW.', color: 'var(--color-accent-danger)' });
                }
            },
            
            async getCameraStream() {
                const resValue = this.nodes.controls.resolution.value;
                const resolution = resValue === '1080p' ? { width: 1920, height: 1080 } : resValue === '480p' ? { width: 640, height: 480 } : { width: 1280, height: 720 };
                const constraints = { video: { ...resolution, facingMode: { ideal: this.state.currentFacingMode }, frameRate: { ideal: 30 } }, audio: true };
                return navigator.mediaDevices.getUserMedia(constraints);
            },
            
            switchCamera() {
                this.state.currentFacingMode = this.state.currentFacingMode === 'user' ? 'environment' : 'user';
                this.restartStream();
            },

            async restartStream() {
                if (this.state.isRecording) return;
                this.stopProcessingLoop();
                if (this.state.stream) this.state.stream.getTracks().forEach(track => track.stop());
                try {
                    this.state.stream = await this.getCameraStream();
                    this.nodes.video.srcObject = this.state.stream;
                    this.nodes.video.onloadedmetadata = () => {
                        this.nodes.viewfinder.width = this.nodes.video.videoWidth;
                        this.nodes.viewfinder.height = this.nodes.video.videoHeight;
                        this.startProcessingLoop();
                    };
                } catch(err) {
                    console.error("Failed to restart stream:", err);
                    alert("Failed to switch camera. The requested camera may not be available at this resolution.");
                }
            },
            
            startSystem() {
                this.UIManager.hideSplashScreen();
                this.UIManager.showApp();
                this.nodes.viewfinder.width = this.nodes.video.videoWidth;
                this.nodes.viewfinder.height = this.nodes.video.videoHeight;
                this.contexts.viewfinder = this.nodes.viewfinder.getContext('2d', { willReadFrequently: true });
                this.setupWorker();
                this.startProcessingLoop();
            },
            
            setupWorker() {
                const workerBlob = new Blob([document.getElementById('scope-worker').textContent], { type: 'application/javascript' });
                this.state.scopeWorker = new Worker(URL.createObjectURL(workerBlob));
                const histogramOffscreen = this.nodes.scopes.histogram.transferControlToOffscreen();
                const waveformOffscreen = this.nodes.scopes.waveform.transferControlToOffscreen();
                this.state.scopeWorker.postMessage({ type: 'init', payload: { histogramCanvas: histogramOffscreen, waveformCanvas: waveformOffscreen } }, [histogramOffscreen, waveformOffscreen]);
                this.state.scopeWorker.onmessage = (e) => {
                    if (e.data.type === 'renderReady') {
                        this.contexts.histogram.clearRect(0, 0, this.nodes.scopes.histogram.width, this.nodes.scopes.histogram.height);
                        this.contexts.histogram.drawImage(e.data.payload.histogramBitmap, 0, 0);
                        this.contexts.waveform.clearRect(0, 0, this.nodes.scopes.waveform.width, this.nodes.scopes.waveform.height);
                        this.contexts.waveform.drawImage(e.data.payload.waveformBitmap, 0, 0);
                        this.state.isProcessingFrame = false;
                    }
                };
                this.contexts.histogram = this.nodes.scopes.histogram.getContext('2d');
                this.contexts.waveform = this.nodes.scopes.waveform.getContext('2d');
            },

            startProcessingLoop() {
                if (this.state.animationFrameId) cancelAnimationFrame(this.state.animationFrameId);
                const loop = () => {
                    if (!this.state.stream || this.nodes.video.paused || this.nodes.video.ended) return;
                    this.contexts.viewfinder.drawImage(this.nodes.video, 0, 0, this.nodes.viewfinder.width, this.nodes.viewfinder.height);
                    const imageData = this.contexts.viewfinder.getImageData(0, 0, this.nodes.viewfinder.width, this.nodes.viewfinder.height);
                    const profile = this.logProfiles[this.state.currentLogProfile];
                    if (profile.b !== 0) this.applyLogTransform(imageData.data, profile.a, profile.b);
                    this.contexts.viewfinder.putImageData(imageData, 0, 0);
                    if (!this.state.isProcessingFrame) {
                        this.state.isProcessingFrame = true;
                        this.state.scopeWorker.postMessage({ type: 'processFrame', payload: { imageData: imageData.data, sourceWidth: this.nodes.viewfinder.width, sourceHeight: this.nodes.viewfinder.height } });
                    }
                    if (this.state.isRecording) this.UIManager.updateTimecode(this.state.recordingStartTime);
                    this.state.animationFrameId = requestAnimationFrame(loop);
                };
                this.state.animationFrameId = requestAnimationFrame(loop);
            },
            
            stopProcessingLoop() {
                if(this.state.animationFrameId) { cancelAnimationFrame(this.state.animationFrameId); this.state.animationFrameId = null; }
            },

            applyLogTransform(data, a, b) {
                const inv255 = 1 / 255;
                for (let i = 0; i < data.length; i += 4) {
                    data[i]     = a * Math.log10(b * (data[i]     * inv255) + 1.0) * 255;
                    data[i + 1] = a * Math.log10(b * (data[i + 1] * inv255) + 1.0) * 255;
                    data[i + 2] = a * Math.log10(b * (data[i + 2] * inv255) + 1.0) * 255;
                }
            },
            
            // =================================================================================
            // [RE-ARCHITECTED] RECORDING LOGIC
            // =================================================================================

            toggleRecording() {
                if (!this.state.isRecording) {
                    this.startRecording();
                } else {
                    this.stopRecording();
                }
            },

            startRecording() {
                if (!this.state.stream) {
                    alert("Camera stream is not available. Cannot start recording.");
                    return;
                }
                
                this.state.isRecording = true;
                this.state.recordedChunks = [];
                this.UIManager.setRecordingState(true);

                // [CRITICAL] Synthesize a new, stable stream for the recorder.
                const videoTrack = this.nodes.viewfinder.captureStream(30).getVideoTracks()[0];
                const audioTracks = this.state.stream.getAudioTracks();
                const combinedStream = new MediaStream([videoTrack]);
                if (audioTracks.length > 0) {
                    combinedStream.addTrack(audioTracks[0]);
                }
                
                const options = { 
                    mimeType: MediaRecorder.isTypeSupported('video/webm; codecs=vp9') ? 'video/webm; codecs=vp9' : 'video/webm; codecs=vp8', 
                    videoBitsPerSecond: 10000000 
                };
                
                try {
                    this.state.mediaRecorder = new MediaRecorder(combinedStream, options);
                } catch(e) {
                    console.error("Monumental failure to instantiate MediaRecorder:", e);
                    alert("Could not start recorder. The selected codec may not be supported on this device.");
                    this.stopRecording(true); // Force stop on failure
                    return;
                }

                // [CRITICAL] Proactive error handling.
                this.state.mediaRecorder.onerror = (event) => {
                    console.error("MediaRecorder Monumental Error:", event.error);
                    alert(`Recording failed: ${event.error.name}. The recording has been stopped.`);
                    this.stopRecording(true); // Force stop on failure
                };
                
                this.state.mediaRecorder.ondataavailable = (event) => { 
                    if (event.data.size > 0) {
                        this.state.recordedChunks.push(event.data); 
                    }
                };

                this.state.mediaRecorder.onstop = () => {
                    // Only process the clip if the stop was not due to an error.
                    if (this.state.recordedChunks.length > 0) {
                        this.addClipToGallery();
                    } else {
                        console.warn("Recording stopped, but no data was captured.");
                    }
                    this.state.mediaRecorder = null; // Clean up instance
                };

                this.state.mediaRecorder.start();
                this.state.recordingStartTime = Date.now();
                this.UIManager.updateTimecode(this.state.recordingStartTime);
            },

            stopRecording(isFailure = false) {
                this.state.isRecording = false;
                this.UIManager.setRecordingState(false);
                
                if (this.state.mediaRecorder && this.state.mediaRecorder.state === 'recording') {
                    this.state.mediaRecorder.stop();
                }

                if (isFailure) {
                    // If it was a failure, clear any potentially corrupt chunks.
                    this.state.recordedChunks = [];
                }
            },

            // =================================================================================
            
            // ... [Identical functions from previous version go here] ...
            async addClipToGallery() {
                const videoBlob = new Blob(this.state.recordedChunks, { type: 'video/webm' });
                const videoUrl = URL.createObjectURL(videoBlob);
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const clipId = `clip-${timestamp}`;
                const metadata = {
                    id: clipId, timestamp_utc: new Date().toISOString(), log_profile: this.logProfiles[this.state.currentLogProfile], resolution: { width: this.nodes.viewfinder.width, height: this.nodes.viewfinder.height }, duration: Date.now() - this.state.recordingStartTime, engine: "CINE-LOG.WEB v2.1",
                };
                const thumbnail = await this.generateThumbnail(videoUrl);
                const clipData = { id: clipId, videoBlob: videoBlob, videoUrl: videoUrl, meta: metadata, thumbnailUrl: thumbnail };
                this.state.galleryClips.push(clipData);
                this.UIManager.updateGalleryNotification(true);
            },
            generateThumbnail(videoUrl) {
                return new Promise((resolve) => {
                    const video = document.createElement('video');
                    const canvas = document.createElement('canvas');
                    video.style.display = 'none';
                    canvas.style.display = 'none';
                    document.body.appendChild(video);
                    document.body.appendChild(canvas);
                    video.src = videoUrl;
                    video.muted = true;
                    video.onloadeddata = () => { video.currentTime = 0.1; };
                    video.onseeked = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
                        resolve(canvas.toDataURL('image/jpeg', 0.8));
                        document.body.removeChild(video);
                        document.body.removeChild(canvas);
                    };
                    video.onerror = () => {
                        resolve(null);
                        document.body.removeChild(video);
                        document.body.removeChild(canvas);
                    };
                });
            },
            playClip(clipId) {
                const clip = this.state.galleryClips.find(c => c.id === clipId);
                if (clip) { this.UIManager.showPlayer(clip.videoUrl); }
            },
            downloadClip(clipId) {
                const clip = this.state.galleryClips.find(c => c.id === clipId);
                if (!clip) return;
                const videoFilename = `CINE-LOG_${clip.id}.webm`;
                const metaFilename = `CINE-LOG_${clip.id}_meta.json`;
                const metaBlob = new Blob([JSON.stringify(clip.meta, null, 2)], { type: 'application/json' });
                const aVideo = document.createElement('a');
                aVideo.href = clip.videoUrl;
                aVideo.download = videoFilename;
                aVideo.click();
                const aMeta = document.createElement('a');
                aMeta.href = URL.createObjectURL(metaBlob);
                aMeta.download = metaFilename;
                aMeta.click();
                URL.revokeObjectURL(aMeta.href);
            },
            deleteClip(clipId) {
                const clipIndex = this.state.galleryClips.findIndex(c => c.id === clipId);
                if (clipIndex > -1) {
                    const clip = this.state.galleryClips[clipIndex];
                    URL.revokeObjectURL(clip.videoUrl);
                    if (clip.thumbnailUrl) URL.revokeObjectURL(clip.thumbnailUrl);
                    this.state.galleryClips.splice(clipIndex, 1);
                    this.UIManager.removeGalleryItem(clipId);
                }
            },
            async updateBatteryStatus() {
                try {
                    if ('getBattery' in navigator) {
                        const battery = await navigator.getBattery();
                        this.UIManager.updateBatteryDisplay(battery.level, battery.charging);
                    }
                } catch (err) { this.nodes.batteryStatus.textContent = `BATT N/A`; }
            },
            UIManager: {
                showDialog(dialogNode) { gsap.set(dialogNode, { display: 'flex' }); gsap.to(dialogNode, { duration: 1, opacity: 1, ease: 'power2.out' }); },
                hideDialog(dialogNode) { gsap.to(dialogNode, { duration: 0.5, opacity: 0, ease: 'power2.in', onComplete: () => dialogNode.style.display = 'none' }); },
                hideSplashScreen() { gsap.to(CineLogApp.nodes.splash.screen, { opacity: 0, duration: 1, ease: 'power2.inOut', onComplete: () => CineLogApp.nodes.splash.screen.style.display = 'none' }); },
                showApp() { gsap.timeline().set(CineLogApp.nodes.app, { visibility: 'visible', opacity: 0 }).to(CineLogApp.nodes.app, { opacity: 1, duration: 1.5, ease: 'power2.out' }); },
                setRecordingState(isRecording) {
                    const { recIndicator, recIndicatorText, controls } = CineLogApp.nodes;
                    recIndicator.classList.toggle('recording', isRecording);
                    controls.recordButton.classList.toggle('recording', isRecording);
                    recIndicatorText.textContent = isRecording ? 'REC' : 'STANDBY';
                },
                updateTimecode(startTime) {
                    const e = Date.now() - startTime, s = Math.floor(e / 1000);
                    const h=String(Math.floor(s/3600)).padStart(2,'0'), m=String(Math.floor((s%3600)/60)).padStart(2,'0'), sec=String(s%60).padStart(2,'0'), f=String(Math.floor((e%1000)/(1000/30))).padStart(2,'0');
                    CineLogApp.nodes.timecode.textContent = `${h}:${m}:${sec}:${f}`;
                },
                updateBatteryDisplay(level, isCharging) {
                    const { batteryStatus } = CineLogApp.nodes;
                    const levelPercent = Math.floor(level * 100);
                    batteryStatus.textContent = `BATT ${levelPercent}% ${isCharging ? '⚡' : ''}`;
                    batteryStatus.style.color = levelPercent < 20 && !isCharging ? 'var(--color-accent-danger)' : 'var(--color-text-primary)';
                },
                updateGalleryNotification(show) { CineLogApp.nodes.gallery.notification.classList.toggle('visible', show); CineLogApp.state.hasNewClips = show; },
                showGallery(clips, nodes, app) {
                    this.updateGalleryNotification(false);
                    nodes.grid.innerHTML = '';
                    clips.forEach(clip => {
                        const itemHTML = `<div class="gallery-item" data-clip-id="${clip.id}"><img src="${clip.thumbnailUrl}" class="gallery-item-thumb" alt="Clip thumbnail"><div class="play-icon-overlay"><svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></div><div class="gallery-item-overlay"><div class="gallery-item-info"><strong>${new Date(clip.meta.timestamp_utc).toLocaleTimeString()}</strong><br><span>${(clip.meta.duration / 1000).toFixed(1)}s</span></div><div class="gallery-item-actions"><button data-action="download" title="Download Clip"><svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg></button><button data-action="delete" title="Delete Clip"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button></div></div></div>`;
                        nodes.grid.insertAdjacentHTML('beforeend', itemHTML);
                    });
                    gsap.set(nodes.view, { display: 'flex', opacity: 0 });
                    gsap.to(nodes.view, { opacity: 1, duration: 0.5, ease: 'power2.out' });
                },
                hideGallery() { gsap.to(CineLogApp.nodes.gallery.view, { opacity: 0, duration: 0.3, ease: 'power2.in', onComplete: () => CineLogApp.nodes.gallery.view.style.display = 'none' }); },
                removeGalleryItem(clipId) { const item = CineLogApp.nodes.gallery.grid.querySelector(`[data-clip-id="${clipId}"]`); if(item) { gsap.to(item, { scale: 0.8, opacity: 0, duration: 0.3, onComplete: () => item.remove() }); } },
                showPlayer(videoUrl) {
                    const { playerView, playerVideo } = CineLogApp.nodes.gallery;
                    playerVideo.src = videoUrl;
                    gsap.set(playerView, { display: 'flex', opacity: 0 });
                    gsap.to(playerView, { opacity: 1, duration: 0.3, ease: 'power2.out' });
                    playerVideo.play();
                },
                hidePlayer() {
                    const { playerView, playerVideo } = CineLogApp.nodes.gallery;
                    playerVideo.pause();
                    playerVideo.src = '';
                    gsap.to(playerView, { opacity: 0, duration: 0.3, ease: 'power2.in', onComplete: () => playerView.style.display = 'none' });
                }
            }
        };

        CineLogApp.init();
    });
    </script>
</body>
</html>
