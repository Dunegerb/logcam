<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>LOGARITHM</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        :root {
            --primary-color: #f5f5f7;
            --accent-color: #0A84FF; /* Um azul "Pro" mais sutil que o vermelho de alerta */
            --rec-color: #ff3b30;
            --background-color: #000000;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --ui-bg: rgba(28, 28, 30, 0.75);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: var(--background-color);
            font-family: var(--font-family);
            -webkit-font-smoothing: antialiased;
            color: var(--primary-color);
        }
        #app-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #main-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between;
            pointer-events: none; opacity: 0; transition: opacity 0.5s ease-in-out;
        }
        #ui-overlay.visible { opacity: 1; }
        .safe-area {
            padding: env(safe-area-inset-top, 15px) env(safe-area-inset-right, 20px) env(safe-area-inset-bottom, 15px) env(safe-area-inset-left, 20px);
            display: flex; flex-direction: column; justify-content: space-between; height: 100%;
        }
        .top-bar, .bottom-bar { width: 100%; display: flex; justify-content: space-between; align-items: center; text-shadow: 0 1px 3px rgba(0,0,0,0.6); }
        .top-bar { font-size: 14px; font-weight: 700; }
        #status-indicator { display: flex; align-items: center; gap: 8px; }
        #rec-dot { width: 10px; height: 10px; background: var(--rec-color); border-radius: 50%; display: none; }
        #rec-dot.active { display: block; animation: pulse 1.5s infinite; }
        #record-button {
            pointer-events: all; background: transparent; border: none;
            width: 70px; height: 70px; cursor: pointer; position: relative;
            display: flex; justify-content: center; align-items: center; outline: none;
        }
        .record-ring {
            width: 64px; height: 64px; border: 3px solid var(--primary-color);
            border-radius: 50%; transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
        }
        #record-button.recording .record-ring { transform: scale(0.9); opacity: 0.5; }
        #record-button::before {
            content: ''; position: absolute;
            width: 64px; height: 64px; background: var(--primary-color); border-radius: 50%;
            transform: scale(0.9); opacity: 0; transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
        }
        #record-button.recording::before {
            transform: scale(0.4); background: var(--rec-color);
            border-radius: 8px; opacity: 1;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        #startup-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--background-color);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s ease, visibility 0.5s;
        }
        #startup-screen.hidden { opacity: 0; visibility: hidden; }
        #startup-screen h1 { font-size: 24px; font-weight: 700; margin-bottom: 10px; color: var(--primary-color); }
        #startup-screen p { max-width: 80%; text-align: center; color: #8e8e93; margin-bottom: 30px; line-height: 1.4; }
        #start-camera-btn {
            font-size: 16px; font-weight: 600; padding: 15px 30px; border-radius: 30px;
            border: none; background: var(--accent-color); color: white; cursor: pointer;
        }
        #error-message {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background: #ff453a; color: white; padding: 10px 20px; border-radius: 10px;
            z-index: 200; display: none; font-size: 14px; text-align: center;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <canvas id="main-canvas"></canvas>
        <video id="raw-video" autoplay playsinline muted style="display:none;"></video>
        <canvas id="hidden-canvas" style="display:none;"></canvas>

        <div id="startup-screen">
            <h1>LOGARITHM</h1>
            <p>Um negativo digital para cinematografia móvel. Toque para iniciar.</p>
            <button id="start-camera-btn">Ativar Câmera</button>
        </div>

        <div id="ui-overlay">
            <div class="safe-area">
                <div class="top-bar">
                    <div id="status-indicator">
                        <div id="rec-dot"></div>
                        <span id="status-text"></span>
                    </div>
                    <span id="resolution"></span>
                </div>
                <div class="bottom-bar">
                    <button id="record-button" disabled></button>
                </div>
            </div>
        </div>

        <div id="error-message"></div>
    </div>

    <script>
    class LogarithmTrueNegative {
        constructor() {
            this.elements = {
                startupScreen: document.getElementById('startup-screen'),
                startBtn: document.getElementById('start-camera-btn'),
                uiOverlay: document.getElementById('ui-overlay'),
                video: document.getElementById('raw-video'),
                mainCanvas: document.getElementById('main-canvas'),
                hiddenCanvas: document.getElementById('hidden-canvas'),
                recordBtn: document.getElementById('record-button'),
                resolutionDisplay: document.getElementById('resolution'),
                statusText: document.getElementById('status-text'),
                recDot: document.getElementById('rec-dot'),
                errorMessage: document.getElementById('error-message')
            };
            this.mainCtx = this.elements.mainCanvas.getContext('2d');
            this.hiddenCtx = this.elements.hiddenCanvas.getContext('2d');
            this.state = {
                isProcessing: false,
                isRecording: false,
                stream: null,
                mediaRecorder: null,
                recordedChunks: [],
                logLut: null
            };
            
            this.init();
        }

        init() {
            // A etapa mais crucial: Pré-calcular a matemática complexa ANTES de qualquer outra coisa.
            this.precomputeLogLut();
            this.elements.startBtn.addEventListener('click', () => this.startCamera());
            this.elements.recordBtn.addEventListener('click', () => this.toggleRecording());
        }

        precomputeLogLut() {
            // Esta função é o coração da nossa otimização.
            // Ela cria uma "tabela de consulta" (Look-Up Table) para a transformação LOG.
            
            // Constantes do nosso perfil "LGM-Log", ajustadas para o espaço de 8 bits.
            // 'b' controla a "elevação" das sombras.
            const b = 150; 
            // 'a' normaliza a saída para que o branco (1.0) mapeie para o branco (1.0).
            const a = 1.0 / Math.log10(b * 1.0 + 1.0);

            const lut = new Uint8ClampedArray(256);
            for (let i = 0; i < 256; i++) {
                // 1. Normalizar o valor de entrada de 8 bits (0-255) para o intervalo linear (0-1).
                const linearInput = i / 255.0;
                
                // 2. Corrigir o gama. Vídeos da web estão em sRGB (gama ~2.2).
                // Precisamos convertê-los para um espaço linear para a matemática funcionar corretamente.
                const gammaCorrected = Math.pow(linearInput, 2.2);

                // 3. Aplicar a fórmula LOG precisa.
                const logValue = a * Math.log10(b * gammaCorrected + 1.0);

                // 4. Converter o resultado de volta para o intervalo de 8 bits (0-255) e armazenar na tabela.
                lut[i] = logValue * 255.0;
            }
            this.state.logLut = lut;
            console.log("LOG Look-Up Table (LUT) pré-computada com sucesso.");
        }
        
        showError(message) {
            this.elements.errorMessage.textContent = message;
            this.elements.errorMessage.style.display = 'block';
            setTimeout(() => { this.elements.errorMessage.style.display = 'none'; }, 5000);
        }

        async startCamera() {
            this.elements.startBtn.disabled = true;
            this.elements.startBtn.textContent = 'Iniciando...';
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                this.showError('API de câmera não suportada.'); return;
            }

            const constraints = { video: { facingMode: 'environment' }, audio: true };
            try {
                this.state.stream = await navigator.mediaDevices.getUserMedia(constraints);
                this.elements.video.srcObject = this.state.stream;
                this.elements.video.onloadedmetadata = () => {
                    this.setupCanvases();
                    this.state.isProcessing = true;
                    this.processFrame();
                    this.elements.startupScreen.classList.add('hidden');
                    this.elements.uiOverlay.classList.add('visible');
                    this.elements.recordBtn.disabled = false;
                };
            } catch (err) {
                console.error("Erro ao acessar a câmera: ", err);
                this.showError('Não foi possível acessar a câmera. Use HTTPS e conceda permissão.');
                this.elements.startBtn.disabled = false;
                this.elements.startBtn.textContent = 'Tentar Novamente';
            }
        }
        
        setupCanvases() {
            const { videoWidth, videoHeight } = this.elements.video;
            this.elements.resolutionDisplay.textContent = `${videoHeight}p`;
            this.elements.hiddenCanvas.width = videoWidth;
            this.elements.hiddenCanvas.height = videoHeight;
            this.elements.mainCanvas.width = window.innerWidth;
            this.elements.mainCanvas.height = window.innerHeight;
        }

        processFrame() {
            if (!this.state.isProcessing) return;

            const { video, hiddenCanvas, mainCanvas } = this.elements;
            const { hiddenCtx, mainCtx } = this;
            const { width, height } = hiddenCanvas;

            if (width === 0) { requestAnimationFrame(() => this.processFrame()); return; }

            hiddenCtx.drawImage(video, 0, 0, width, height);
            const imageData = hiddenCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const lut = this.state.logLut;

            // O loop de processamento agora é incrivelmente rápido graças ao LUT.
            for (let i = 0; i < data.length; i += 4) {
                // Em vez de cálculos complexos, fazemos uma busca de array instantânea.
                data[i]     = lut[data[i]];   // Canal Vermelho
                data[i + 1] = lut[data[i + 1]]; // Canal Verde
                data[i + 2] = lut[data[i + 2]]; // Canal Azul
                // O canal Alpha (transparência) permanece intacto.
            }

            hiddenCtx.putImageData(imageData, 0, 0);
            mainCtx.drawImage(hiddenCanvas, 0, 0, mainCanvas.width, mainCanvas.height);

            requestAnimationFrame(() => this.processFrame());
        }
        
        toggleRecording() {
            this.state.isRecording = !this.state.isRecording;
            this.elements.recordBtn.classList.toggle('recording', this.state.isRecording);
            
            if (this.state.isRecording) this.startRecording();
            else this.stopRecording();
        }

        startRecording() {
            if (!this.elements.mainCanvas.captureStream || typeof MediaRecorder === 'undefined') {
                this.showError('API de gravação não suportada.');
                this.state.isRecording = false;
                this.elements.recordBtn.classList.remove('recording');
                return;
            }
            
            this.state.recordedChunks = [];
            const canvasStream = this.elements.mainCanvas.captureStream(30);
            const audioTracks = this.state.stream.getAudioTracks();
            if (audioTracks.length > 0) canvasStream.addTrack(audioTracks[0]);
            
            this.state.mediaRecorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm; codecs=vp9' });
            this.state.mediaRecorder.ondataavailable = e => { if (e.data.size > 0) this.state.recordedChunks.push(e.data); };
            this.state.mediaRecorder.onstart = () => {
                this.elements.recDot.classList.add('active');
                this.elements.statusText.textContent = 'REC';
            };
            this.state.mediaRecorder.onstop = () => {
                this.elements.recDot.classList.remove('active');
                this.elements.statusText.textContent = '';
                const blob = new Blob(this.state.recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `LOGARITHM_${Date.now()}.webm`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            };
            this.state.mediaRecorder.start();
        }

        stopRecording() {
            if (this.state.mediaRecorder && this.state.mediaRecorder.state === 'recording') {
                this.state.mediaRecorder.stop();
            }
        }
    }

    window.addEventListener('load', () => new LogarithmTrueNegative());
    </script>
</body>
</html>
