<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CINE-LOG.WEB | Real-time LOG Video Pipeline</title>
    <meta name="description" content="A monumental in-browser application for real-time LOG video recording and processing, built as a testament to the absolute limits of web engineering.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;700&family=Teko:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        /* [1] === CORE RESET & THEME ARCHITECTURE === */
        :root {
            --color-background: #000000;
            --color-primary-dark: #0a0a0a;
            --color-primary-medium: #111111;
            --color-primary-light: #1a1a1a;
            --color-accent: #00ffff;
            --color-accent-secondary: #ff00ff;
            --color-accent-danger: #ff4141;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #8a8a8a;
            --font-primary: 'Teko', sans-serif;
            --font-secondary: 'Roboto Mono', monospace;
            --transition-speed: 0.3s;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--color-background);
            color: var(--color-text-primary);
            font-family: var(--font-secondary);
            font-size: 10px;
            -webkit-tap-highlight-color: transparent;
        }

        /* [2] === SPLASH SCREEN / BOOT SEQUENCE === */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--color-background);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: var(--color-accent);
        }

        #splash-logo {
            font-family: var(--font-primary);
            font-size: 8rem;
            font-weight: 600;
            letter-spacing: 4px;
            opacity: 0;
            transform: translateY(20px);
        }
        #splash-logo span {
            color: var(--color-text-primary);
            font-weight: 300;
        }

        #progress-bar-container {
            width: 80%;
            max-width: 400px;
            height: 2px;
            background: rgba(0, 255, 255, 0.2);
            margin-top: 2rem;
            opacity: 0;
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: var(--color-accent);
        }

        #splash-status {
            margin-top: 1.5rem;
            font-size: 1.4rem;
            letter-spacing: 1px;
            opacity: 0;
            text-transform: uppercase;
        }

        /* [3] === MAIN APPLICATION INTERFACE === */
        #app-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            visibility: hidden;
            opacity: 0;
            background: var(--color-primary-dark);
        }

        #video-viewfinder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #video-element {
            display: none;
        }
        
        /* [4] === HEADS-UP DISPLAY (HUD) & OVERLAYS === */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: grid;
            grid-template-rows: 60px 1fr 120px;
            grid-template-columns: 150px 1fr 150px;
        }

        .hud-element {
            padding: 1rem;
            color: var(--color-text-primary);
            font-size: 1.2rem;
            text-shadow: 0 0 5px rgba(0,0,0,0.7);
        }

        /* Status Bar (Top) */
        #status-bar {
            grid-column: 1 / 4;
            grid-row: 1 / 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
            padding: 1rem 2rem;
        }
        
        #rec-indicator {
            display: flex;
            align-items: center;
            font-weight: 700;
            font-size: 1.8rem;
            letter-spacing: 2px;
            color: var(--color-text-secondary);
            transition: color var(--transition-speed);
        }
        #rec-indicator.recording {
            color: var(--color-accent-danger);
        }
        #rec-indicator .dot {
            width: 10px;
            height: 10px;
            background-color: currentColor;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse-animation 1.5s infinite;
            opacity: 0;
            transition: opacity var(--transition-speed);
        }
        #rec-indicator.recording .dot {
            opacity: 1;
        }
        @keyframes pulse-animation {
            0% { transform: scale(1); }
            50% { transform: scale(0.8); }
            100% { transform: scale(1); }
        }

        #timecode {
            font-size: 1.8rem;
            font-weight: 700;
        }
        
        #battery-status {
            font-size: 1.4rem;
        }
        
        /* Analysis Scopes (Left) */
        #scopes-panel {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding-left: 1rem;
        }

        .scope-container {
            background: rgba(10, 10, 10, 0.7);
            border: 1px solid var(--color-primary-light);
            border-radius: 4px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 0.5rem;
        }
        .scope-container h3 {
            font-family: var(--font-primary);
            font-size: 1.6rem;
            font-weight: 400;
            color: var(--color-accent);
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .scope-canvas {
            width: 100%;
            aspect-ratio: 4/3;
        }
        
        /* Control Panel (Right) */
        #control-panel {
            grid-column: 3 / 4;
            grid-row: 2 / 3;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            padding-right: 1rem;
            pointer-events: all;
        }
        
        .control-group {
            background: rgba(10, 10, 10, 0.7);
            border: 1px solid var(--color-primary-light);
            border-radius: 4px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 1rem;
        }
        .control-group label {
            display: block;
            font-family: var(--font-primary);
            font-size: 1.6rem;
            color: var(--color-accent);
            margin-bottom: 0.8rem;
        }
        .control-group select, .control-group input {
            width: 100%;
            background: var(--color-primary-medium);
            border: 1px solid var(--color-primary-light);
            color: var(--color-text-primary);
            font-family: var(--font-secondary);
            padding: 0.5rem;
            border-radius: 2px;
            font-size: 1.2rem;
        }
        
        /* Main Actions (Bottom) */
        #action-bar {
            grid-column: 1 / 4;
            grid-row: 3 / 4;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 3rem; /* Space for the new button */
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
            pointer-events: all;
        }
        
        #record-button {
            width: 70px;
            height: 70px;
            background: var(--color-primary-dark);
            border: 4px solid var(--color-text-secondary);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all var(--transition-speed) ease;
        }
        #record-button .inner-circle {
            width: 80%;
            height: 80%;
            background: var(--color-accent-danger);
            border-radius: 50%;
            transition: all var(--transition-speed) ease;
        }
        
        #record-button.recording {
             border-color: var(--color-accent-danger);
        }
        #record-button.recording .inner-circle {
            border-radius: 15%;
            transform: scale(0.8);
        }

        /* NEW: Switch Camera Button */
        #switch-camera-button {
            width: 50px;
            height: 50px;
            background: var(--color-primary-medium);
            border: 2px solid var(--color-text-secondary);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all var(--transition-speed) ease;
        }
        #switch-camera-button:hover {
            border-color: var(--color-accent);
        }
        #switch-camera-button svg {
            width: 24px;
            height: 24px;
            fill: var(--color-text-primary);
            transition: fill var(--transition-speed) ease;
        }
        #switch-camera-button:hover svg {
            fill: var(--color-accent);
        }
        
        /* [5] === MODAL / DIALOGS === */
        #permission-dialog, #download-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10001; 
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            display: none;
            opacity: 0;
        }
        .dialog-content {
            background: var(--color-primary-dark);
            border: 1px solid var(--color-accent);
            padding: 3rem;
            max-width: 500px;
            text-align: center;
        }
        .dialog-content h2 {
            font-family: var(--font-primary);
            font-size: 3rem;
            color: var(--color-accent);
            margin-bottom: 1.5rem;
        }
        .dialog-content p {
            font-size: 1.4rem;
            line-height: 1.6;
            margin-bottom: 2rem;
            color: var(--color-text-secondary);
        }
        .dialog-button {
            background: var(--color-accent);
            color: var(--color-background);
            border: none;
            padding: 1rem 3rem;
            font-family: var(--font-secondary);
            font-size: 1.6rem;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition-speed);
        }
        .dialog-button:hover {
            opacity: 0.8;
        }
        #download-links {
            margin-top: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #download-links a {
            color: var(--color-accent);
            font-size: 1.4rem;
            text-decoration: none;
            border: 1px solid var(--color-accent);
            padding: 0.8rem;
            display: block;
        }
    </style>
</head>
<body>
    <div id="splash-screen">
        <div id="splash-logo">CINE-LOG<span>.WEB</span></div>
        <div id="progress-bar-container"><div id="progress-bar"></div></div>
        <div id="splash-status">INITIALIZING KERNEL</div>
    </div>

    <div id="app-container">
        <video id="video-element" playsinline autoplay muted></video>
        <canvas id="video-viewfinder"></canvas>
        <div class="hud">
            <div id="status-bar" class="hud-element">
                <div id="rec-indicator"><div class="dot"></div><span>STANDBY</span></div>
                <div id="timecode">00:00:00:00</div>
                <div id="battery-status">BATT --%</div>
            </div>
            <div id="scopes-panel" class="hud-element">
                <div class="scope-container">
                    <h3>LUMA HISTOGRAM</h3>
                    <canvas id="histogram-canvas" class="scope-canvas"></canvas>
                </div>
                <div class="scope-container">
                    <h3>LUMA WAVEFORM</h3>
                    <canvas id="waveform-canvas" class="scope-canvas"></canvas>
                </div>
            </div>
            <div id="control-panel" class="hud-element">
                <div class="control-group">
                    <label for="log-profile-select">LOG PROFILE</label>
                    <select id="log-profile-select">
                        <option value="weblog">WEB-LOG (Generic)</option>
                        <option value="clog">CINE-LOG (High DR)</option>
                        <option value="slog">SAT-LOG (Punchy)</option>
                        <option value="linear">LINEAR (No LOG)</option>
                    </select>
                </div>
                 <div class="control-group">
                    <label for="resolution-select">RESOLUTION</label>
                    <select id="resolution-select">
                        <option value="1080p">1920x1080</option>
                        <option value="720p" selected>1280x720</option>
                        <option value="480p">640x480</option>
                    </select>
                </div>
            </div>
            <div id="action-bar" class="hud-element">
                <!-- The new switch camera button, a testament to foresight -->
                <div id="switch-camera-button">
                    <svg viewBox="0 0 24 24"><path d="M19.8 12c0-3.92-2.9-7.14-6.68-7.43L12 3V1h-1v2.03C7.1 3.32 4.2 6.54 4.2 10.46V12H2v8h20v-8h-2.2zM8 18H6v-4h2v4zm4 0h-2v-4h2v4zm4 0h-2v-4h2v4zm3.5-12.28C17.63 4.6 15.43 4 13 4s-4.63.6-6.5 1.72V1H5v5h14V1h-1.5v4.72z"/></svg>
                </div>
                <div id="record-button"><div class="inner-circle"></div></div>
                <!-- Placeholder for future controls -->
                <div style="width: 50px; height: 50px;"></div>
            </div>
        </div>
    </div>
    
    <div id="permission-dialog">
        <div class="dialog-content">
            <h2>ACCESS REQUIRED</h2>
            <p>CINE-LOG.WEB requires access to your device's camera to initiate the real-time processing pipeline.</p>
            <button id="grant-permission-button" class="dialog-button">GRANT ACCESS</button>
        </div>
    </div>

    <div id="download-dialog">
        <div class="dialog-content">
            <h2>RECORDING COMPLETE</h2>
            <p>Your LOG footage has been encoded. Download both the video file and the accompanying metadata JSON file.</p>
            <div id="download-links"></div>
            <button id="close-download-button" class="dialog-button">CLOSE</button>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const CineLogApp = {
            nodes: {
                splash: {
                    screen: document.getElementById('splash-screen'),
                    logo: document.getElementById('splash-logo'),
                    progressBarContainer: document.getElementById('progress-bar-container'),
                    progressBar: document.getElementById('progress-bar'),
                    status: document.getElementById('splash-status')
                },
                app: document.getElementById('app-container'),
                video: document.getElementById('video-element'),
                viewfinder: document.getElementById('video-viewfinder'),
                recIndicator: document.getElementById('rec-indicator'),
                recIndicatorText: document.querySelector('#rec-indicator span'),
                timecode: document.getElementById('timecode'),
                batteryStatus: document.getElementById('battery-status'),
                scopes: {
                    histogram: document.getElementById('histogram-canvas'),
                    waveform: document.getElementById('waveform-canvas'),
                },
                controls: {
                    recordButton: document.getElementById('record-button'),
                    switchCameraButton: document.getElementById('switch-camera-button'), // New control
                    logProfile: document.getElementById('log-profile-select'),
                    resolution: document.getElementById('resolution-select')
                },
                dialogs: {
                    permission: document.getElementById('permission-dialog'),
                    permissionButton: document.getElementById('grant-permission-button'),
                    download: document.getElementById('download-dialog'),
                    downloadLinks: document.getElementById('download-links'),
                    closeDownloadButton: document.getElementById('close-download-button')
                }
            },

            state: {
                isRecording: false,
                stream: null,
                mediaRecorder: null,
                recordedChunks: [],
                recordingStartTime: 0,
                animationFrameId: null,
                currentLogProfile: 'weblog',
                currentFacingMode: 'environment' // CRITICAL: Default to rear camera
            },
            
            logProfiles: {
                'weblog': { name: 'WEB-LOG (Generic)', a: 0.25, b: 150 },
                'clog':   { name: 'CINE-LOG (High DR)', a: 0.20, b: 400 },
                'slog':   { name: 'SAT-LOG (Punchy)', a: 0.35, b: 80 },
                'linear': { name: 'LINEAR (No LOG)', a: 1, b: 0 }
            },
            
            contexts: { viewfinder: null, histogram: null, waveform: null },

            init() {
                this.bootSequence();
                this.setupEventListeners();
                this.updateBatteryStatus();
                setInterval(this.updateBatteryStatus, 60000);
            },

            bootSequence() {
                const statusUpdates = ["MOUNTING VFS...", "LOADING COLOR SCIENCE...", "CALIBRATING SENSORS...", "AWAITING PERMISSION..."];
                const tl = gsap.timeline({
                    onComplete: () => {
                        gsap.to([this.nodes.splash.logo, this.nodes.splash.progressBarContainer], { duration: 0.5, opacity: 0, ease: 'power2.in' });
                        gsap.set(this.nodes.dialogs.permission, { display: 'flex' });
                        gsap.to(this.nodes.dialogs.permission, { duration: 1, opacity: 1, ease: 'power2.out' });
                    }
                });

                tl.to(this.nodes.splash.logo, { opacity: 1, y: 0, duration: 1.5, ease: 'power3.out' })
                  .to(this.nodes.splash.progressBarContainer, { opacity: 1, duration: 0.5 }, "-=1")
                  .to(this.nodes.splash.status, { opacity: 1, duration: 0.5 }, "-=1");

                statusUpdates.forEach((status, index) => {
                    tl.to(this.nodes.splash.progressBar, {
                        width: `${(index + 1) / statusUpdates.length * 100}%`,
                        duration: 0.7,
                        ease: 'none'
                    }).set(this.nodes.splash.status, { textContent: status });
                });
            },
            
            setupEventListeners() {
                this.nodes.dialogs.permissionButton.addEventListener('click', () => this.requestCameraPermission());
                this.nodes.controls.recordButton.addEventListener('click', () => this.toggleRecording());
                this.nodes.controls.switchCameraButton.addEventListener('click', () => this.switchCamera());
                this.nodes.controls.logProfile.addEventListener('change', (e) => this.state.currentLogProfile = e.target.value);
                this.nodes.controls.resolution.addEventListener('change', () => this.restartStream());
                this.nodes.dialogs.closeDownloadButton.addEventListener('click', () => {
                    gsap.to(this.nodes.dialogs.download, { opacity: 0, duration: 0.3, onComplete: () => {
                        this.nodes.dialogs.download.style.display = 'none';
                    }});
                });
            },

            async getCameraStream() {
                const resolution = this.getResolution();
                // THE CORE CORRECTION: Explicitly request the desired camera.
                const constraints = {
                    video: {
                        width: { ideal: resolution.width },
                        height: { ideal: resolution.height },
                        facingMode: { ideal: this.state.currentFacingMode },
                        frameRate: { ideal: 30 }
                    },
                    audio: true
                };
                return navigator.mediaDevices.getUserMedia(constraints);
            },
            
            async requestCameraPermission() {
                gsap.to(this.nodes.dialogs.permission, { 
                    duration: 0.5, opacity: 0, ease: 'power2.in',
                    onComplete: () => this.nodes.dialogs.permission.style.display = 'none' 
                });
                
                this.nodes.splash.status.textContent = 'ACCESSING CAMERA STREAM...';
                gsap.fromTo(this.nodes.splash.status, { opacity: 0 }, { opacity: 1, duration: 0.5 });
                
                try {
                    this.state.stream = await this.getCameraStream();
                    this.nodes.video.srcObject = this.state.stream;
                    this.nodes.video.onloadedmetadata = () => this.startSystem();
                } catch (err) {
                    console.error("Monumental Error: Camera access denied or unavailable.", err);
                    this.nodes.splash.status.textContent = 'CAMERA ACCESS DENIED. REFRESH & ALLOW.';
                    gsap.to(this.nodes.splash.status, { color: 'var(--color-accent-danger)' });
                }
            },
            
            getResolution() {
                const resValue = this.nodes.controls.resolution.value;
                if (resValue === '1080p') return { width: 1920, height: 1080 };
                if (resValue === '480p') return { width: 640, height: 480 };
                return { width: 1280, height: 720 };
            },

            // New function for toggling camera
            switchCamera() {
                this.state.currentFacingMode = this.state.currentFacingMode === 'user' ? 'environment' : 'user';
                this.restartStream();
            },

            async restartStream() {
                if (this.state.isRecording) return; // Prevent switching while recording
                this.stopProcessingLoop();
                if (this.state.stream) {
                    this.state.stream.getTracks().forEach(track => track.stop());
                }
                
                try {
                    this.state.stream = await this.getCameraStream();
                    this.nodes.video.srcObject = this.state.stream;
                    this.nodes.video.onloadedmetadata = () => {
                        this.nodes.viewfinder.width = this.nodes.video.videoWidth;
                        this.nodes.viewfinder.height = this.nodes.video.videoHeight;
                        this.contexts.viewfinder = this.nodes.viewfinder.getContext('2d', { willReadFrequently: true });
                        this.setupScopes();
                        this.startProcessingLoop();
                        this.setupMediaRecorder();
                    };
                } catch(err) {
                    console.error("Failed to restart stream:", err);
                    alert("Failed to switch camera. The requested camera may not be available at this resolution.");
                }
            },
            
            startSystem() {
                const tl = gsap.timeline();
                tl.to(this.nodes.splash.screen, { 
                    opacity: 0, duration: 1, ease: 'power2.inOut',
                    onComplete: () => this.nodes.splash.screen.style.display = 'none' 
                })
                  .set(this.nodes.app, { visibility: 'visible', opacity: 0 })
                  .to(this.nodes.app, { opacity: 1, duration: 1.5, ease: 'power2.out' }, "-=0.5");

                this.nodes.viewfinder.width = this.nodes.video.videoWidth;
                this.nodes.viewfinder.height = this.nodes.video.videoHeight;
                this.contexts.viewfinder = this.nodes.viewfinder.getContext('2d', { willReadFrequently: true });
                
                this.setupScopes();
                this.startProcessingLoop();
                this.setupMediaRecorder();
            },
            
            setupScopes() {
                ['histogram', 'waveform'].forEach(scope => {
                    const canvas = this.nodes.scopes[scope];
                    canvas.width = 128;
                    canvas.height = 96;
                    this.contexts[scope] = canvas.getContext('2d');
                });
            },

            startProcessingLoop() {
                if (this.state.animationFrameId) cancelAnimationFrame(this.state.animationFrameId);
                const loop = () => {
                    if (!this.state.stream || this.nodes.video.paused || this.nodes.video.ended) return;
                    
                    this.contexts.viewfinder.drawImage(this.nodes.video, 0, 0, this.nodes.viewfinder.width, this.nodes.viewfinder.height);
                    const imageData = this.contexts.viewfinder.getImageData(0, 0, this.nodes.viewfinder.width, this.nodes.viewfinder.height);
                    const profile = this.logProfiles[this.state.currentLogProfile];

                    if (profile.b !== 0) {
                         this.applyLogTransform(imageData.data, profile.a, profile.b);
                    }
                    
                    this.contexts.viewfinder.putImageData(imageData, 0, 0);
                    this.updateScopes(imageData.data);
                    
                    if (this.state.isRecording) this.updateTimecode();
                    this.state.animationFrameId = requestAnimationFrame(loop);
                };
                this.state.animationFrameId = requestAnimationFrame(loop);
            },
            
            stopProcessingLoop() {
                if(this.state.animationFrameId) {
                    cancelAnimationFrame(this.state.animationFrameId);
                    this.state.animationFrameId = null;
                }
            },

            applyLogTransform(data, a, b) {
                for (let i = 0; i < data.length; i += 4) {
                    const r_lin = data[i] / 255; const g_lin = data[i + 1] / 255; const b_lin = data[i + 2] / 255;
                    const r_log = a * Math.log10(b * r_lin + 1.0); const g_log = a * Math.log10(b * g_lin + 1.0); const b_log = a * Math.log10(b * b_lin + 1.0);
                    data[i] = r_log * 255; data[i + 1] = g_log * 255; data[i + 2] = b_log * 255;
                }
            },
            
            updateScopes(data) {
                const lumaValues = new Uint8ClampedArray(data.length / 4);
                for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                    lumaValues[j] = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
                }
                this.drawHistogram(lumaValues);
                this.drawWaveform(lumaValues);
            },
            
            drawHistogram(lumaValues) {
                const ctx = this.contexts.histogram;
                const bins = new Uint32Array(256).fill(0);
                for (let i = 0; i < lumaValues.length; i++) { bins[lumaValues[i]]++; }
                let maxBin = 0;
                for (let i = 0; i < 256; i++) { if (bins[i] > maxBin) maxBin = bins[i]; }
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.fillStyle = `rgba(0, 255, 255, 0.7)`;
                for (let i = 0; i < 256; i++) {
                    const height = (bins[i] / maxBin) * ctx.canvas.height;
                    const x = (i / 256) * ctx.canvas.width;
                    const width = ctx.canvas.width / 256;
                    ctx.fillRect(x, ctx.canvas.height - height, width, height);
                }
            },
            
            drawWaveform(lumaValues) {
                const ctx = this.contexts.waveform;
                const width = this.nodes.viewfinder.width; const height = this.nodes.viewfinder.height;
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                const densityData = new Uint8ClampedArray(ctx.canvas.width * ctx.canvas.height).fill(0);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const luma = lumaValues[y * width + x];
                        const waveformX = Math.floor((x / width) * ctx.canvas.width);
                        const waveformY = Math.floor(ctx.canvas.height - 1 - (luma / 255) * (ctx.canvas.height-1));
                        const index = waveformY * ctx.canvas.width + waveformX;
                        if(densityData[index] < 255) densityData[index] += 4;
                    }
                }
                const imgData = ctx.createImageData(ctx.canvas.width, ctx.canvas.height);
                for(let i=0; i < densityData.length; i++) {
                    const density = densityData[i];
                    const baseIndex = i * 4;
                    if(density > 0) {
                        imgData.data[baseIndex] = 0;
                        imgData.data[baseIndex + 1] = Math.min(255, density * 10);
                        imgData.data[baseIndex + 2] = Math.min(255, density * 10);
                        imgData.data[baseIndex + 3] = 255;
                    }
                }
                ctx.putImageData(imgData, 0, 0);
            },

            setupMediaRecorder() {
                const canvasStream = this.nodes.viewfinder.captureStream(30);
                const audioTracks = this.state.stream.getAudioTracks();
                if (audioTracks.length > 0) { canvasStream.addTrack(audioTracks[0]); }
                let options = { mimeType: 'video/webm; codecs=vp9' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) { options = { mimeType: 'video/webm; codecs=vp8' }; }
                this.state.mediaRecorder = new MediaRecorder(canvasStream, options);
                this.state.mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) this.state.recordedChunks.push(event.data); };
                this.state.mediaRecorder.onstop = () => this.createDownloadables();
            },

            toggleRecording() {
                if (this.state.mediaRecorder.state === 'inactive') {
                    this.state.isRecording = true;
                    this.state.recordedChunks = [];
                    this.state.mediaRecorder.start();
                    this.state.recordingStartTime = Date.now();
                    this.nodes.recIndicator.classList.add('recording');
                    this.nodes.recIndicatorText.textContent = 'REC';
                    this.nodes.controls.recordButton.classList.add('recording');
                } else {
                    this.state.isRecording = false;
                    this.state.mediaRecorder.stop();
                    this.nodes.recIndicator.classList.remove('recording');
                    this.nodes.recIndicatorText.textContent = 'STANDBY';
                    this.nodes.controls.recordButton.classList.remove('recording');
                }
            },

            createDownloadables() {
                const videoBlob = new Blob(this.state.recordedChunks, { type: 'video/webm' });
                const videoUrl = URL.createObjectURL(videoBlob);
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const videoFilename = `CINE-LOG_${timestamp}.webm`;
                const metaFilename = `CINE-LOG_${timestamp}_meta.json`;
                const metadata = {
                    timestamp_utc: new Date().toISOString(),
                    log_profile: this.logProfiles[this.state.currentLogProfile],
                    resolution: { width: this.nodes.viewfinder.width, height: this.nodes.viewfinder.height },
                    engine: "CINE-LOG.WEB v1.0",
                    notes: "Crucial for post-production. Use 'log_profile' parameters to invert the LOG curve to linear space before grading."
                };
                const metaBlob = new Blob([JSON.stringify(metadata, null, 2)], { type: 'application/json' });
                const metaUrl = URL.createObjectURL(metaBlob);
                this.nodes.dialogs.downloadLinks.innerHTML = `
                    <a href="${videoUrl}" download="${videoFilename}">DOWNLOAD VIDEO (.webm)</a>
                    <a href="${metaUrl}" download="${metaFilename}">DOWNLOAD METADATA (.json)</a>`;
                gsap.set(this.nodes.dialogs.download, { display: 'flex' });
                gsap.to(this.nodes.dialogs.download, { opacity: 1, duration: 0.5 });
            },

            updateTimecode() {
                const elapsed = Date.now() - this.state.recordingStartTime;
                const s = Math.floor(elapsed / 1000);
                const h = String(Math.floor(s/3600)).padStart(2,'0');
                const m = String(Math.floor((s%3600)/60)).padStart(2,'0');
                const sec = String(s%60).padStart(2,'0');
                const f = String(Math.floor((elapsed%1000)/(1000/30))).padStart(2,'0');
                this.nodes.timecode.textContent = `${h}:${m}:${sec}:${f}`;
            },

            async updateBatteryStatus() {
                try {
                    if ('getBattery' in navigator) {
                        const battery = await navigator.getBattery();
                        const level = Math.floor(battery.level * 100);
                        this.nodes.batteryStatus.textContent = `BATT ${level}%`;
                        this.nodes.batteryStatus.style.color = level < 20 ? 'var(--color-accent-danger)' : 'var(--color-text-primary)';
                    }
                } catch (err) { this.nodes.batteryStatus.textContent = `BATT N/A`; }
            }
        };

        CineLogApp.init();
    });
    </script>
</body>
</html>
