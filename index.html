<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CINE-LOG.WEB | Real-time LOG Video Pipeline</title>
    <meta name="description" content="A monumental in-browser application for real-time LOG video recording and processing, built as a testament to the absolute limits of web engineering.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;700&family=Teko:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        /* [1] === CORE RESET & THEME ARCHITECTURE === */
        :root {
            --color-background: #000000;
            --color-primary-dark: #0a0a0a;
            --color-primary-medium: #111111;
            --color-primary-light: #1a1a1a;
            --color-accent: #00ffff;
            --color-accent-secondary: #ff00ff;
            --color-accent-danger: #ff4141;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #8a8a8a;
            --font-primary: 'Teko', sans-serif;
            --font-secondary: 'Roboto Mono', monospace;
            --transition-speed: 0.3s;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--color-background);
            color: var(--color-text-primary);
            font-family: var(--font-secondary);
            font-size: 10px;
            -webkit-tap-highlight-color: transparent;
        }

        /* [2] === SPLASH SCREEN / BOOT SEQUENCE === */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--color-background);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: var(--color-accent);
        }

        #splash-logo {
            font-family: var(--font-primary);
            font-size: 8rem;
            font-weight: 600;
            letter-spacing: 4px;
            opacity: 0;
            transform: translateY(20px);
        }
        #splash-logo span {
            color: var(--color-text-primary);
            font-weight: 300;
        }

        #progress-bar-container {
            width: 80%;
            max-width: 400px;
            height: 2px;
            background: rgba(0, 255, 255, 0.2);
            margin-top: 2rem;
            opacity: 0;
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: var(--color-accent);
        }

        #splash-status {
            margin-top: 1.5rem;
            font-size: 1.4rem;
            letter-spacing: 1px;
            opacity: 0;
            text-transform: uppercase;
        }

        /* [3] === MAIN APPLICATION INTERFACE === */
        #app-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            visibility: hidden;
            opacity: 0;
            background: var(--color-primary-dark);
        }

        #video-viewfinder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #video-element {
            display: none; /* The raw feed is hidden, processing happens on canvas */
        }
        
        /* [4] === HEADS-UP DISPLAY (HUD) & OVERLAYS === */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: grid;
            grid-template-rows: 60px 1fr 120px;
            grid-template-columns: 150px 1fr 150px;
        }

        .hud-element {
            padding: 1rem;
            color: var(--color-text-primary);
            font-size: 1.2rem;
            text-shadow: 0 0 5px rgba(0,0,0,0.7);
        }

        /* Status Bar (Top) */
        #status-bar {
            grid-column: 1 / 4;
            grid-row: 1 / 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
            padding: 1rem 2rem;
        }
        
        #rec-indicator {
            display: flex;
            align-items: center;
            font-weight: 700;
            font-size: 1.8rem;
            letter-spacing: 2px;
            color: var(--color-text-secondary);
            transition: color var(--transition-speed);
        }
        #rec-indicator.recording {
            color: var(--color-accent-danger);
        }
        #rec-indicator .dot {
            width: 10px;
            height: 10px;
            background-color: currentColor;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse-animation 1.5s infinite;
            opacity: 0;
            transition: opacity var(--transition-speed);
        }
        #rec-indicator.recording .dot {
            opacity: 1;
        }
        @keyframes pulse-animation {
            0% { transform: scale(1); }
            50% { transform: scale(0.8); }
            100% { transform: scale(1); }
        }

        #timecode {
            font-size: 1.8rem;
            font-weight: 700;
        }
        
        #battery-status {
            font-size: 1.4rem;
        }
        
        /* Analysis Scopes (Left) */
        #scopes-panel {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding-left: 1rem;
        }

        .scope-container {
            background: rgba(10, 10, 10, 0.7);
            border: 1px solid var(--color-primary-light);
            border-radius: 4px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 0.5rem;
        }
        .scope-container h3 {
            font-family: var(--font-primary);
            font-size: 1.6rem;
            font-weight: 400;
            color: var(--color-accent);
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .scope-canvas {
            width: 100%;
            aspect-ratio: 4/3;
        }
        
        /* Control Panel (Right) */
        #control-panel {
            grid-column: 3 / 4;
            grid-row: 2 / 3;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            padding-right: 1rem;
            pointer-events: all;
        }
        
        .control-group {
            background: rgba(10, 10, 10, 0.7);
            border: 1px solid var(--color-primary-light);
            border-radius: 4px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 1rem;
        }
        .control-group label {
            display: block;
            font-family: var(--font-primary);
            font-size: 1.6rem;
            color: var(--color-accent);
            margin-bottom: 0.8rem;
        }
        .control-group select, .control-group input {
            width: 100%;
            background: var(--color-primary-medium);
            border: 1px solid var(--color-primary-light);
            color: var(--color-text-primary);
            font-family: var(--font-secondary);
            padding: 0.5rem;
            border-radius: 2px;
            font-size: 1.2rem;
        }
        
        /* Main Actions (Bottom) */
        #action-bar {
            grid-column: 1 / 4;
            grid-row: 3 / 4;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
            pointer-events: all;
        }
        
        #record-button {
            width: 70px;
            height: 70px;
            background: var(--color-primary-dark);
            border: 4px solid var(--color-text-secondary);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all var(--transition-speed) ease;
        }
        #record-button .inner-circle {
            width: 80%;
            height: 80%;
            background: var(--color-accent-danger);
            border-radius: 50%;
            transition: all var(--transition-speed) ease;
        }
        
        #record-button.recording {
             border-color: var(--color-accent-danger);
        }
        #record-button.recording .inner-circle {
            border-radius: 15%;
            transform: scale(0.8);
        }
        
        /* [5] === MODAL / DIALOGS === */
        #permission-dialog, #download-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            /* Z-INDEX CORRECTION: Ensure dialogs are on top of the splash screen */
            z-index: 10001; 
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            display: none; /* Initially hidden */
            opacity: 0; /* Control visibility with GSAP for smooth transitions */
        }
        .dialog-content {
            background: var(--color-primary-dark);
            border: 1px solid var(--color-accent);
            padding: 3rem;
            max-width: 500px;
            text-align: center;
        }
        .dialog-content h2 {
            font-family: var(--font-primary);
            font-size: 3rem;
            color: var(--color-accent);
            margin-bottom: 1.5rem;
        }
        .dialog-content p {
            font-size: 1.4rem;
            line-height: 1.6;
            margin-bottom: 2rem;
            color: var(--color-text-secondary);
        }
        .dialog-button {
            background: var(--color-accent);
            color: var(--color-background);
            border: none;
            padding: 1rem 3rem;
            font-family: var(--font-secondary);
            font-size: 1.6rem;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition-speed);
        }
        .dialog-button:hover {
            opacity: 0.8;
        }
        #download-links {
            margin-top: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #download-links a {
            color: var(--color-accent);
            font-size: 1.4rem;
            text-decoration: none;
            border: 1px solid var(--color-accent);
            padding: 0.8rem;
            display: block;
        }

    </style>
</head>
<body>

    <!-- Splash Screen: The grand entrance, setting the professional tone -->
    <div id="splash-screen">
        <div id="splash-logo">CINE-LOG<span>.WEB</span></div>
        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div id="splash-status">INITIALIZING KERNEL</div>
    </div>

    <!-- Main Application Container: The heart of the instrument -->
    <div id="app-container">
        <video id="video-element" playsinline autoplay muted></video>
        <canvas id="video-viewfinder"></canvas>
        <div class="hud">
            <div id="status-bar" class="hud-element">
                <div id="rec-indicator">
                    <div class="dot"></div>
                    <span>STANDBY</span>
                </div>
                <div id="timecode">00:00:00:00</div>
                <div id="battery-status">BATT --%</div>
            </div>
            <div id="scopes-panel" class="hud-element">
                <div class="scope-container">
                    <h3>LUMA HISTOGRAM</h3>
                    <canvas id="histogram-canvas" class="scope-canvas"></canvas>
                </div>
                <div class="scope-container">
                    <h3>LUMA WAVEFORM</h3>
                    <canvas id="waveform-canvas" class="scope-canvas"></canvas>
                </div>
            </div>
            <div id="control-panel" class="hud-element">
                <div class="control-group">
                    <label for="log-profile-select">LOG PROFILE</label>
                    <select id="log-profile-select">
                        <option value="weblog">WEB-LOG (Generic)</option>
                        <option value="clog">CINE-LOG (High DR)</option>
                        <option value="slog">SAT-LOG (Punchy)</option>
                        <option value="linear">LINEAR (No LOG)</option>
                    </select>
                </div>
                 <div class="control-group">
                    <label for="resolution-select">RESOLUTION</label>
                    <select id="resolution-select">
                        <option value="1080p">1920x1080</option>
                        <option value="720p" selected>1280x720</option>
                        <option value="480p">640x480</option>
                    </select>
                </div>
                 <div class="control-group">
                    <label>POST-LUT</label>
                    <p style="font-size: 1rem; color: var(--color-text-secondary);">Rec.709 LUT not applied. Recording clean LOG signal.</p>
                </div>
            </div>
            <div id="action-bar" class="hud-element">
                <div id="record-button">
                    <div class="inner-circle"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Permission Dialog -->
    <div id="permission-dialog">
        <div class="dialog-content">
            <h2>ACCESS REQUIRED</h2>
            <p>CINE-LOG.WEB requires access to your device's camera to initiate the real-time processing pipeline. Your data is processed entirely on-device and is never uploaded.</p>
            <button id="grant-permission-button" class="dialog-button">GRANT ACCESS</button>
        </div>
    </div>

    <!-- Download Dialog -->
    <div id="download-dialog">
        <div class="dialog-content">
            <h2>RECORDING COMPLETE</h2>
            <p>Your LOG footage has been encoded. For a professional post-production workflow, download both the video file and the accompanying metadata JSON file.</p>
            <div id="download-links"></div>
            <button id="close-download-button" class="dialog-button">CLOSE</button>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const CineLogApp = {
            nodes: {
                splash: {
                    screen: document.getElementById('splash-screen'),
                    logo: document.getElementById('splash-logo'),
                    progressBarContainer: document.getElementById('progress-bar-container'),
                    progressBar: document.getElementById('progress-bar'),
                    status: document.getElementById('splash-status')
                },
                app: document.getElementById('app-container'),
                video: document.getElementById('video-element'),
                viewfinder: document.getElementById('video-viewfinder'),
                recIndicator: document.getElementById('rec-indicator'),
                recIndicatorText: document.querySelector('#rec-indicator span'),
                timecode: document.getElementById('timecode'),
                batteryStatus: document.getElementById('battery-status'),
                scopes: {
                    histogram: document.getElementById('histogram-canvas'),
                    waveform: document.getElementById('waveform-canvas'),
                },
                controls: {
                    recordButton: document.getElementById('record-button'),
                    logProfile: document.getElementById('log-profile-select'),
                    resolution: document.getElementById('resolution-select')
                },
                dialogs: {
                    permission: document.getElementById('permission-dialog'),
                    permissionButton: document.getElementById('grant-permission-button'),
                    download: document.getElementById('download-dialog'),
                    downloadLinks: document.getElementById('download-links'),
                    closeDownloadButton: document.getElementById('close-download-button')
                }
            },

            state: {
                isRecording: false,
                stream: null,
                mediaRecorder: null,
                recordedChunks: [],
                recordingStartTime: 0,
                animationFrameId: null,
                currentLogProfile: 'weblog'
            },
            
            logProfiles: {
                'weblog': { name: 'WEB-LOG (Generic)', a: 0.25, b: 150 },
                'clog':   { name: 'CINE-LOG (High DR)', a: 0.20, b: 400 },
                'slog':   { name: 'SAT-LOG (Punchy)', a: 0.35, b: 80 },
                'linear': { name: 'LINEAR (No LOG)', a: 1, b: 0 }
            },
            
            contexts: {
                viewfinder: null,
                histogram: null,
                waveform: null,
            },

            // --- [PHASE 1: INITIALIZATION] ---
            init() {
                this.bootSequence();
                this.setupEventListeners();
                this.updateBatteryStatus();
                setInterval(this.updateBatteryStatus, 60000);
            },

            bootSequence() {
                const statusUpdates = [
                    "MOUNTING VFS...",
                    "LOADING COLOR SCIENCE MODULES...",
                    "CALIBRATING SENSORS...",
                    "AWAITING USER PERMISSION..."
                ];

                // RE-ARCHITECTED BOOT TIMELINE
                const tl = gsap.timeline({
                    onComplete: () => {
                        // This callback executes only after the entire animation is finished.
                        // It fades out the boot text and fades in the permission dialog,
                        // ensuring a clean, logical, and visible transition.
                        gsap.to([this.nodes.splash.logo, this.nodes.splash.progressBarContainer], {
                            duration: 0.5, opacity: 0, ease: 'power2.in'
                        });
                        
                        // Use GSAP to control the dialog's appearance for a smooth fade-in.
                        gsap.set(this.nodes.dialogs.permission, { display: 'flex' });
                        gsap.to(this.nodes.dialogs.permission, { duration: 1, opacity: 1, ease: 'power2.out' });
                    }
                });

                tl.to(this.nodes.splash.logo, { opacity: 1, y: 0, duration: 1.5, ease: 'power3.out' })
                  .to(this.nodes.splash.progressBarContainer, { opacity: 1, duration: 0.5 }, "-=1")
                  .to(this.nodes.splash.status, { opacity: 1, duration: 0.5 }, "-=1");

                statusUpdates.forEach((status, index) => {
                    tl.to(this.nodes.splash.progressBar, {
                        width: `${(index + 1) / statusUpdates.length * 100}%`,
                        duration: 0.7,
                        ease: 'none'
                    }).set(this.nodes.splash.status, { textContent: status });
                });
            },
            
            setupEventListeners() {
                this.nodes.dialogs.permissionButton.addEventListener('click', () => this.requestCameraPermission());
                this.nodes.controls.recordButton.addEventListener('click', () => this.toggleRecording());
                this.nodes.controls.logProfile.addEventListener('change', (e) => this.state.currentLogProfile = e.target.value);
                this.nodes.controls.resolution.addEventListener('change', () => this.restartStream());
                this.nodes.dialogs.closeDownloadButton.addEventListener('click', () => {
                    gsap.to(this.nodes.dialogs.download, { opacity: 0, duration: 0.3, onComplete: () => {
                        this.nodes.dialogs.download.style.display = 'none';
                    }});
                });
            },

            // --- [PHASE 2: CAMERA & STREAM MANAGEMENT] ---
            async requestCameraPermission() {
                // Provide immediate feedback by hiding the dialog and updating the status.
                gsap.to(this.nodes.dialogs.permission, { 
                    duration: 0.5, 
                    opacity: 0, 
                    ease: 'power2.in',
                    onComplete: () => this.nodes.dialogs.permission.style.display = 'none' 
                });
                
                this.nodes.splash.status.textContent = 'ACCESSING CAMERA STREAM...';
                gsap.fromTo(this.nodes.splash.status, { opacity: 0 }, { opacity: 1, duration: 0.5 });
                
                try {
                    const resolution = this.getResolution();
                    const constraints = {
                        video: {
                            width: { ideal: resolution.width },
                            height: { ideal: resolution.height },
                            frameRate: { ideal: 30 }
                        },
                        audio: true
                    };

                    this.state.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.nodes.video.srcObject = this.state.stream;
                    // The 'onloadedmetadata' event is the true signal that the stream is ready for processing.
                    this.nodes.video.onloadedmetadata = () => {
                        this.startSystem();
                    };
                } catch (err) {
                    console.error("Monumental Error: Camera access denied or unavailable.", err);
                    // CRITICAL: Provide clear error feedback to the user.
                    this.nodes.splash.status.textContent = 'CAMERA ACCESS DENIED. REFRESH & ALLOW.';
                    gsap.to(this.nodes.splash.status, { color: 'var(--color-accent-danger)' });
                }
            },
            
            getResolution() {
                const resValue = this.nodes.controls.resolution.value;
                if (resValue === '1080p') return { width: 1920, height: 1080 };
                if (resValue === '480p') return { width: 640, height: 480 };
                return { width: 1280, height: 720 };
            },

            async restartStream() {
                this.stopProcessingLoop();
                if (this.state.stream) {
                    this.state.stream.getTracks().forEach(track => track.stop());
                }
                // We don't need to ask for permission again, just get a new stream with new constraints
                try {
                     const resolution = this.getResolution();
                     const constraints = {
                        video: {
                            width: { ideal: resolution.width },
                            height: { ideal: resolution.height },
                            frameRate: { ideal: 30 }
                        },
                        audio: true
                    };
                    this.state.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.nodes.video.srcObject = this.state.stream;
                    this.nodes.video.onloadedmetadata = () => {
                        // Re-initialize the processing parts without the full boot sequence
                        this.nodes.viewfinder.width = this.nodes.video.videoWidth;
                        this.nodes.viewfinder.height = this.nodes.video.videoHeight;
                        this.contexts.viewfinder = this.nodes.viewfinder.getContext('2d', { willReadFrequently: true });
                        this.setupScopes();
                        this.startProcessingLoop();
                        this.setupMediaRecorder();
                    };
                } catch(err) {
                    console.error("Failed to restart stream:", err);
                }
            },
            
            // --- [PHASE 3: SYSTEM START & PROCESSING CORE] ---
            startSystem() {
                // This is the final, glorious transition from splash to application.
                const tl = gsap.timeline();
                tl.to(this.nodes.splash.screen, { 
                    opacity: 0, 
                    duration: 1, 
                    ease: 'power2.inOut',
                    onComplete: () => this.nodes.splash.screen.style.display = 'none' 
                })
                  .set(this.nodes.app, { visibility: 'visible', opacity: 0 })
                  .to(this.nodes.app, { opacity: 1, duration: 1.5, ease: 'power2.out' }, "-=0.5");

                this.nodes.viewfinder.width = this.nodes.video.videoWidth;
                this.nodes.viewfinder.height = this.nodes.video.videoHeight;
                this.contexts.viewfinder = this.nodes.viewfinder.getContext('2d', { willReadFrequently: true });
                
                this.setupScopes();
                this.startProcessingLoop();
                this.setupMediaRecorder();
            },
            
            setupScopes() {
                ['histogram', 'waveform'].forEach(scope => {
                    const canvas = this.nodes.scopes[scope];
                    canvas.width = 128;
                    canvas.height = 96;
                    this.contexts[scope] = canvas.getContext('2d');
                });
            },

            startProcessingLoop() {
                if (this.state.animationFrameId) cancelAnimationFrame(this.state.animationFrameId);
                const loop = () => {
                    if (!this.state.stream || this.nodes.video.paused || this.nodes.video.ended) return;
                    
                    this.contexts.viewfinder.drawImage(this.nodes.video, 0, 0, this.nodes.viewfinder.width, this.nodes.viewfinder.height);
                    
                    const imageData = this.contexts.viewfinder.getImageData(0, 0, this.nodes.viewfinder.width, this.nodes.viewfinder.height);
                    const profile = this.logProfiles[this.state.currentLogProfile];

                    if (profile.b !== 0) {
                         this.applyLogTransform(imageData.data, profile.a, profile.b);
                    }
                    
                    this.contexts.viewfinder.putImageData(imageData, 0, 0);
                    this.updateScopes(imageData.data);
                    
                    if (this.state.isRecording) this.updateTimecode();

                    this.state.animationFrameId = requestAnimationFrame(loop);
                };
                this.state.animationFrameId = requestAnimationFrame(loop);
            },
            
            stopProcessingLoop() {
                if(this.state.animationFrameId) {
                    cancelAnimationFrame(this.state.animationFrameId);
                    this.state.animationFrameId = null;
                }
            },

            applyLogTransform(data, a, b) {
                for (let i = 0; i < data.length; i += 4) {
                    const r_lin = data[i] / 255;
                    const g_lin = data[i + 1] / 255;
                    const b_lin = data[i + 2] / 255;

                    const r_log = a * Math.log10(b * r_lin + 1.0);
                    const g_log = a * Math.log10(b * g_lin + 1.0);
                    const b_log = a * Math.log10(b * b_lin + 1.0);

                    data[i] = r_log * 255;
                    data[i + 1] = g_log * 255;
                    data[i + 2] = b_log * 255;
                }
            },
            
            // --- [PHASE 4: REAL-TIME ANALYSIS] ---
            updateScopes(data) {
                const lumaValues = new Uint8ClampedArray(data.length / 4);
                for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                    lumaValues[j] = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
                }

                this.drawHistogram(lumaValues);
                this.drawWaveform(lumaValues);
            },
            
            drawHistogram(lumaValues) {
                const ctx = this.contexts.histogram;
                const bins = new Uint32Array(256).fill(0);
                
                for (let i = 0; i < lumaValues.length; i++) {
                    bins[lumaValues[i]]++;
                }
                
                let maxBin = 0;
                for (let i = 0; i < 256; i++) {
                    if (bins[i] > maxBin) maxBin = bins[i];
                }

                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.fillStyle = `rgba(0, 255, 255, 0.7)`;
                
                for (let i = 0; i < 256; i++) {
                    const height = (bins[i] / maxBin) * ctx.canvas.height;
                    const x = (i / 256) * ctx.canvas.width;
                    const width = ctx.canvas.width / 256;
                    ctx.fillRect(x, ctx.canvas.height - height, width, height);
                }
            },
            
            drawWaveform(lumaValues) {
                const ctx = this.contexts.waveform;
                const width = this.nodes.viewfinder.width;
                const height = this.nodes.viewfinder.height;

                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                const densityData = new Uint8ClampedArray(ctx.canvas.width * ctx.canvas.height).fill(0);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const luma = lumaValues[y * width + x];
                        const waveformX = Math.floor((x / width) * ctx.canvas.width);
                        const waveformY = Math.floor(ctx.canvas.height - 1 - (luma / 255) * (ctx.canvas.height-1));
                        const index = waveformY * ctx.canvas.width + waveformX;
                        if(densityData[index] < 255) densityData[index] += 4; // Increased intensity
                    }
                }
                
                const imgData = ctx.createImageData(ctx.canvas.width, ctx.canvas.height);
                for(let i=0; i < densityData.length; i++) {
                    const density = densityData[i];
                    const baseIndex = i * 4;
                    if(density > 0) {
                        imgData.data[baseIndex] = 0;
                        imgData.data[baseIndex + 1] = Math.min(255, density * 10);
                        imgData.data[baseIndex + 2] = Math.min(255, density * 10);
                        imgData.data[baseIndex + 3] = 255;
                    }
                }
                ctx.putImageData(imgData, 0, 0);
            },

            // --- [PHASE 5: RECORDING & METADATA] ---
            setupMediaRecorder() {
                const canvasStream = this.nodes.viewfinder.captureStream(30);
                
                const audioTracks = this.state.stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    canvasStream.addTrack(audioTracks[0]);
                }
                
                let options = { mimeType: 'video/webm; codecs=vp9' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                   console.log(options.mimeType + ' is not supported! Using vp8.');
                   options = { mimeType: 'video/webm; codecs=vp8' };
                }

                this.state.mediaRecorder = new MediaRecorder(canvasStream, options);

                this.state.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.state.recordedChunks.push(event.data);
                    }
                };
                
                this.state.mediaRecorder.onstop = () => {
                    this.createDownloadables();
                };
            },

            toggleRecording() {
                if (this.state.mediaRecorder.state === 'inactive') {
                    this.state.isRecording = true;
                    this.state.recordedChunks = [];
                    this.state.mediaRecorder.start();
                    this.state.recordingStartTime = Date.now();
                    this.nodes.recIndicator.classList.add('recording');
                    this.nodes.recIndicatorText.textContent = 'REC';
                    this.nodes.controls.recordButton.classList.add('recording');
                } else {
                    this.state.isRecording = false;
                    this.state.mediaRecorder.stop();
                    this.nodes.recIndicator.classList.remove('recording');
                    this.nodes.recIndicatorText.textContent = 'STANDBY';
                    this.nodes.controls.recordButton.classList.remove('recording');
                }
            },

            createDownloadables() {
                const videoBlob = new Blob(this.state.recordedChunks, { type: 'video/webm' });
                const videoUrl = URL.createObjectURL(videoBlob);
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const videoFilename = `CINE-LOG_${timestamp}.webm`;
                const metaFilename = `CINE-LOG_${timestamp}_meta.json`;

                const metadata = {
                    timestamp_utc: new Date().toISOString(),
                    log_profile: this.logProfiles[this.state.currentLogProfile],
                    resolution: {
                        width: this.nodes.viewfinder.width,
                        height: this.nodes.viewfinder.height
                    },
                    engine: "CINE-LOG.WEB v1.0",
                    notes: "This metadata file is crucial for color grading. Use the 'log_profile' parameters to correctly invert the LOG curve into a linear color space before applying a creative LUT."
                };
                
                const metaBlob = new Blob([JSON.stringify(metadata, null, 2)], { type: 'application/json' });
                const metaUrl = URL.createObjectURL(metaBlob);

                this.nodes.dialogs.downloadLinks.innerHTML = `
                    <a href="${videoUrl}" download="${videoFilename}">DOWNLOAD VIDEO (.webm)</a>
                    <a href="${metaUrl}" download="${metaFilename}">DOWNLOAD METADATA (.json)</a>
                `;
                gsap.set(this.nodes.dialogs.download, { display: 'flex' });
                gsap.to(this.nodes.dialogs.download, { opacity: 1, duration: 0.5 });
            },

            // --- [PHASE 6: UTILITIES] ---
            updateTimecode() {
                const elapsed = Date.now() - this.state.recordingStartTime;
                const totalSeconds = Math.floor(elapsed / 1000);
                const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
                const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
                const seconds = String(totalSeconds % 60).padStart(2, '0');
                const frames = String(Math.floor((elapsed % 1000) / (1000/30))).padStart(2, '0');
                this.nodes.timecode.textContent = `${hours}:${minutes}:${seconds}:${frames}`;
            },

            async updateBatteryStatus() {
                try {
                    if ('getBattery' in navigator) {
                        const battery = await navigator.getBattery();
                        const level = Math.floor(battery.level * 100);
                        this.nodes.batteryStatus.textContent = `BATT ${level}%`;
                        this.nodes.batteryStatus.style.color = level < 20 ? 'var(--color-accent-danger)' : 'var(--color-text-primary)';
                    }
                } catch (err) {
                     this.nodes.batteryStatus.textContent = `BATT N/A`;
                }
            }
        };

        CineLogApp.init();
    });
    </script>
</body>
</html>
